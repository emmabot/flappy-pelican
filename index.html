<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Flappy Pelican â€” California Coast Edition</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { width: 100%; height: 100%; overflow: hidden; background: #1a0a2e; display: flex; justify-content: center; align-items: center; }
  canvas { display: block; touch-action: none; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
// â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const W = 480, H = 640;
let GRAVITY = 0.40;
let FLAP_STRENGTH = -7.2;
let PIPE_SPEED = 2.5;
const PIPE_WIDTH = 60;
let PIPE_GAP = 140;
let PIPE_SPAWN_INTERVAL = 1600;
const GROUND_HEIGHT = 60;
const PELICAN_W = 40, PELICAN_H = 30;
const PELICAN_X = 80;

// â”€â”€ Difficulty Presets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const DIFFICULTIES = {
  easy:   { gravity: 0.22, flap: -5.8, speed: 1.3, gap: 200, interval: 2800, label: 'Easy', emoji: 'ðŸŒŠ' },
  medium: { gravity: 0.40, flap: -7.2, speed: 2.5, gap: 140, interval: 1600, label: 'Medium', emoji: 'ðŸ„' },
  hard:   { gravity: 0.50, flap: -8.0, speed: 3.2, gap: 115, interval: 1200, label: 'Hard', emoji: 'ðŸ¦ˆ' }
};
let currentDifficulty = localStorage.getItem('flappyPelicanDifficulty') || 'medium';

function applyDifficulty(key) {
  currentDifficulty = key;
  const d = DIFFICULTIES[key];
  GRAVITY = d.gravity;
  FLAP_STRENGTH = d.flap;
  PIPE_SPEED = d.speed;
  PIPE_GAP = d.gap;
  PIPE_SPAWN_INTERVAL = d.interval;
  localStorage.setItem('flappyPelicanDifficulty', key);
}
applyDifficulty(currentDifficulty); // apply on load

// â”€â”€ Habitat System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let currentHabitat = localStorage.getItem('flappyPelicanHabitat') || 'halfmoonbay';
let habitatButtons = []; // [{key, x, y, w, h}, ...]

function selectHabitat(key) {
  currentHabitat = key;
  localStorage.setItem('flappyPelicanHabitat', key);
}

function getHabitat() { return HABITATS[currentHabitat] || HABITATS.halfmoonbay; }

// â”€â”€ Canvas Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = W;
canvas.height = H;

// â”€â”€ Responsive Scaling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resizeCanvas() {
  const scaleX = window.innerWidth / W;
  const scaleY = window.innerHeight / H;
  const scale = Math.min(scaleX, scaleY);
  canvas.style.width = (W * scale) + 'px';
  canvas.style.height = (H * scale) + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// â”€â”€ High Score (per-difficulty) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getBestScore(key) {
  return parseInt(localStorage.getItem('flappyPelicanBest_' + key) || '0', 10);
}
function setBestScore(key, val) {
  localStorage.setItem('flappyPelicanBest_' + key, String(val));
}
let bestScore = getBestScore(currentDifficulty);

// â”€â”€ Game State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let state = 'menu';
let pelican = { y: 0, vy: 0, rotation: 0, wingPhase: 0, flapTimer: 0 };
let pipes = [];
let score = 0;
let lastPipeSpawn = 0;
let lastTime = 0;
let groundOffset = 0;
let parallaxOffset = 0;
let pipeCount = 0;
let simonTriggered = false;
let shakeTimer = 0;
let shakeIntensity = 0;
let scorePopups = [];
let menuIdleStart = performance.now();

function resetGame() {
  pelican.y = H / 2 - 50;
  pelican.vy = 0;
  pelican.rotation = 0;
  pelican.wingPhase = 0;
  pelican.flapTimer = 0;
  pipes = [];
  score = 0;
  lastPipeSpawn = 0;
  lastTime = 0;
  groundOffset = 0;
  pipeCount = 0;
  simonTriggered = false;
  shakeTimer = 0;
  shakeIntensity = 0;
  scorePopups = [];
}

// â”€â”€ Difficulty Button Hit-Test â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Button rects are computed in drawMenu() and stored here for click detection
let difficultyButtons = []; // [{key, x, y, w, h}, ...]

function selectDifficulty(key) {
  applyDifficulty(key);
  bestScore = getBestScore(currentDifficulty);
}

// â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleInput() {
  menuIdleStart = performance.now();
  if (state === 'menu') {
    state = 'playing';
    resetGame();
    lastTime = performance.now();
  } else if (state === 'playing') {
    pelican.vy = FLAP_STRENGTH;
    pelican.flapTimer = 12; // frames of wing-up animation
  } else if (state === 'game_over') {
    state = 'menu';
    bestScore = getBestScore(currentDifficulty);
  }
}

canvas.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  menuIdleStart = performance.now();
  if (state === 'menu') {
    // Convert pointer coords to canvas coords
    const rect = canvas.getBoundingClientRect();
    const scaleX = W / rect.width;
    const scaleY = H / rect.height;
    const cx = (e.clientX - rect.left) * scaleX;
    const cy = (e.clientY - rect.top) * scaleY;
    // Check difficulty buttons
    for (const btn of difficultyButtons) {
      if (cx >= btn.x && cx <= btn.x + btn.w && cy >= btn.y && cy <= btn.y + btn.h) {
        selectDifficulty(btn.key);
        return;
      }
    }
    // Check habitat buttons
    for (const btn of habitatButtons) {
      if (cx >= btn.x && cx <= btn.x + btn.w && cy >= btn.y && cy <= btn.y + btn.h) {
        selectHabitat(btn.key);
        return;
      }
    }
  }
  handleInput();
});
document.addEventListener('keydown', (e) => {
  menuIdleStart = performance.now();
  if (e.code === 'Space' || e.key === ' ') { e.preventDefault(); handleInput(); }
  if (state === 'menu') {
    if (e.key === '1') selectDifficulty('easy');
    if (e.key === '2') selectDifficulty('medium');
    if (e.key === '3') selectDifficulty('hard');
    // Habitat shortcuts: Q W E R T
    const habShortcuts = { q: 'halfmoonbay', w: 'channelislands', e: 'lajolla', r: 'morrobay', t: 'bolsachica' };
    if (habShortcuts[e.key.toLowerCase()]) selectHabitat(habShortcuts[e.key.toLowerCase()]);
  }
});

// â”€â”€ Pipe Generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnPipe() {
  const minTop = 80;
  const maxTop = H - GROUND_HEIGHT - PIPE_GAP - 80;
  const topHeight = minTop + Math.random() * (maxTop - minTop);
  pipeCount++;
  const hasSimon = (!simonTriggered && pipeCount === 11);
  if (hasSimon) simonTriggered = true;
  pipes.push({
    x: W + 10,
    topH: topHeight,
    bottomY: topHeight + PIPE_GAP,
    scored: false,
    hasSimon: hasSimon,
    simonFrame: 0
  });

  // ~30% chance of fish in the gap
  if (Math.random() < 0.3) {
    const lastPipe = pipes[pipes.length - 1];
    const fishTypes = ['anchovy', 'sardine', 'smelt'];
    lastPipe.fish = {
      collected: false,
      y: lastPipe.topH + PIPE_GAP * (0.3 + Math.random() * 0.4),
      type: fishTypes[Math.floor(Math.random() * 3)]
    };
  }
}

// â”€â”€ Collision Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkCollision() {
  const px = PELICAN_X, py = pelican.y;
  const pw = PELICAN_W, ph = PELICAN_H;

  // Ground & ceiling
  if (py + ph >= H - GROUND_HEIGHT) return true;
  if (py <= 0) return true;

  // Pipes
  for (const pipe of pipes) {
    if (px + pw > pipe.x && px < pipe.x + PIPE_WIDTH) {
      if (py < pipe.topH || py + ph > pipe.bottomY) {
        return true;
      }
    }
  }
  return false;
}

// â”€â”€ Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function update(now) {
  if (state !== 'playing') return;

  const dt = Math.min((now - lastTime) / 16.667, 3); // normalize to ~60fps, cap
  lastTime = now;

  // Pelican physics
  pelican.vy += GRAVITY * dt;
  pelican.y += pelican.vy * dt;

  // Rotation based on velocity
  const targetRot = Math.max(-0.5, Math.min(pelican.vy / 10, 1.2));
  pelican.rotation += (targetRot - pelican.rotation) * 0.15 * dt;

  // Wing animation
  if (pelican.flapTimer > 0) pelican.flapTimer -= dt;
  pelican.wingPhase += 0.15 * dt;

  // Ground scroll & parallax
  groundOffset = (groundOffset + PIPE_SPEED * dt) % 24;
  parallaxOffset += PIPE_SPEED * dt;

  // Pipe spawning (time-based)
  if (pipes.length === 0 || (now - lastPipeSpawn) > PIPE_SPAWN_INTERVAL) {
    spawnPipe();
    lastPipeSpawn = now;
  }

  // Move pipes & score
  for (let i = pipes.length - 1; i >= 0; i--) {
    pipes[i].x -= PIPE_SPEED * dt;

    // Score when pelican passes pipe center
    if (!pipes[i].scored && pipes[i].x + PIPE_WIDTH < PELICAN_X) {
      pipes[i].scored = true;
      score++;
    }

    // Fish collection
    if (pipes[i].fish && !pipes[i].fish.collected) {
      const fx = pipes[i].x + PIPE_WIDTH / 2;
      const fy = pipes[i].fish.y;
      const px = PELICAN_X + PELICAN_W / 2;
      const py = pelican.y + PELICAN_H / 2;
      if (Math.abs(px - fx) < 25 && Math.abs(py - fy) < 20) {
        pipes[i].fish.collected = true;
        score += 3;
        scorePopups.push({ x: fx, y: fy, alpha: 1.0, vy: -1.5 });
      }
    }

    // Remove off-screen pipes
    if (pipes[i].x + PIPE_WIDTH < -10) {
      pipes.splice(i, 1);
    }
  }

  // Update score popups
  for (let i = scorePopups.length - 1; i >= 0; i--) {
    scorePopups[i].y += scorePopups[i].vy;
    scorePopups[i].alpha -= 0.02;
    if (scorePopups[i].alpha <= 0) scorePopups.splice(i, 1);
  }

  // Collision
  if (checkCollision()) {
    state = 'game_over';
    shakeTimer = 12;
    shakeIntensity = 6;
    if (score > bestScore) {
      bestScore = score;
      setBestScore(currentDifficulty, bestScore);
    }
  }
}
// â”€â”€ Drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawBackground() {
  // Sunset sky gradient
  const grad = ctx.createLinearGradient(0, 0, 0, H - GROUND_HEIGHT);
  grad.addColorStop(0, '#1a0a3e');
  grad.addColorStop(0.25, '#4a1942');
  grad.addColorStop(0.45, '#c0392b');
  grad.addColorStop(0.6, '#e67e22');
  grad.addColorStop(0.75, '#f39c12');
  grad.addColorStop(1, '#fdeaa8');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H - GROUND_HEIGHT);

  // Sun glow
  const sunY = (H - GROUND_HEIGHT) * 0.62;
  const sunGrad = ctx.createRadialGradient(W * 0.7, sunY, 10, W * 0.7, sunY, 120);
  sunGrad.addColorStop(0, 'rgba(255, 220, 100, 0.8)');
  sunGrad.addColorStop(0.3, 'rgba(255, 180, 60, 0.3)');
  sunGrad.addColorStop(1, 'rgba(255, 100, 50, 0)');
  ctx.fillStyle = sunGrad;
  ctx.fillRect(0, 0, W, H - GROUND_HEIGHT);

  // Sun disc
  ctx.fillStyle = '#ffe066';
  ctx.beginPath();
  ctx.arc(W * 0.7, sunY, 30, 0, Math.PI * 2);
  ctx.fill();

  // â”€â”€ Parallax Layer 1: Distant clouds â”€â”€
  ctx.fillStyle = 'rgba(255, 200, 150, 0.25)';
  const cloudSpeed1 = parallaxOffset * 0.15;
  for (let i = 0; i < 4; i++) {
    const cx = ((i * 160 + 40 - cloudSpeed1) % (W + 120)) - 60;
    drawCloud(cx, 60 + i * 25, 50 + i * 10, 0.2 + i * 0.05);
  }

  // â”€â”€ Parallax Layer 2: Distant hills/coastline â”€â”€
  const hillSpeed = parallaxOffset * 0.3;
  ctx.fillStyle = '#2d1b4e';
  ctx.beginPath();
  ctx.moveTo(0, H - GROUND_HEIGHT);
  for (let x = 0; x <= W; x += 2) {
    const h = Math.sin((x + hillSpeed) * 0.008) * 40 + Math.sin((x + hillSpeed) * 0.02) * 20 + 60;
    ctx.lineTo(x, H - GROUND_HEIGHT - h);
  }
  ctx.lineTo(W, H - GROUND_HEIGHT);
  ctx.closePath();
  ctx.fill();

  // â”€â”€ Parallax Layer 3: Closer hills with palm tree silhouettes â”€â”€
  const hillSpeed2 = parallaxOffset * 0.5;
  ctx.fillStyle = '#1a0f30';
  ctx.beginPath();
  ctx.moveTo(0, H - GROUND_HEIGHT);
  for (let x = 0; x <= W; x += 2) {
    const h = Math.sin((x + hillSpeed2) * 0.012) * 25 + Math.sin((x + hillSpeed2) * 0.03) * 15 + 35;
    ctx.lineTo(x, H - GROUND_HEIGHT - h);
  }
  ctx.lineTo(W, H - GROUND_HEIGHT);
  ctx.closePath();
  ctx.fill();

  // Palm tree silhouettes on closer hills
  ctx.fillStyle = '#1a0f30';
  for (let i = 0; i < 3; i++) {
    const px = ((i * 200 + 80 - hillSpeed2) % (W + 100)) - 50;
    const baseH = Math.sin((px + hillSpeed2) * 0.012) * 25 + Math.sin((px + hillSpeed2) * 0.03) * 15 + 35;
    drawPalmSilhouette(px, H - GROUND_HEIGHT - baseH);
  }
}

function drawCloud(x, y, size, alpha) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = 'rgba(255, 220, 180, 0.6)';
  ctx.beginPath();
  ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
  ctx.arc(x + size * 0.35, y - size * 0.15, size * 0.4, 0, Math.PI * 2);
  ctx.arc(x + size * 0.7, y, size * 0.35, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawPalmSilhouette(x, baseY) {
  // Trunk
  ctx.save();
  ctx.strokeStyle = '#1a0f30';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(x, baseY);
  ctx.quadraticCurveTo(x + 5, baseY - 25, x + 3, baseY - 45);
  ctx.stroke();
  // Fronds
  ctx.fillStyle = '#1a0f30';
  for (let a = -2.5; a <= 0.5; a += 0.5) {
    ctx.beginPath();
    ctx.moveTo(x + 3, baseY - 45);
    const fx = x + 3 + Math.cos(a) * 22;
    const fy = baseY - 45 + Math.sin(a) * 18;
    ctx.quadraticCurveTo(x + 3 + Math.cos(a) * 12, baseY - 45 + Math.sin(a) * 5, fx, fy);
    ctx.quadraticCurveTo(x + 3 + Math.cos(a) * 14, baseY - 45 + Math.sin(a) * 10, x + 3, baseY - 45);
    ctx.fill();
  }
  ctx.restore();
}

function drawWater() {
  const waterY = H - GROUND_HEIGHT;
  // Deep water base
  const wGrad = ctx.createLinearGradient(0, waterY, 0, H);
  wGrad.addColorStop(0, '#1a3a5c');
  wGrad.addColorStop(0.3, '#0d2137');
  wGrad.addColorStop(1, '#091520');
  ctx.fillStyle = wGrad;
  ctx.fillRect(0, waterY, W, GROUND_HEIGHT);

  // Sunset reflection on water
  const refGrad = ctx.createLinearGradient(0, waterY, 0, waterY + 30);
  refGrad.addColorStop(0, 'rgba(255, 150, 50, 0.3)');
  refGrad.addColorStop(1, 'rgba(255, 100, 30, 0)');
  ctx.fillStyle = refGrad;
  ctx.fillRect(0, waterY, W, 30);

  // Animated waves
  const t = performance.now() * 0.002;
  ctx.strokeStyle = 'rgba(100, 180, 255, 0.25)';
  ctx.lineWidth = 1.5;
  for (let row = 0; row < 3; row++) {
    ctx.beginPath();
    const wy = waterY + 8 + row * 18;
    for (let x = 0; x <= W; x += 3) {
      const wave = Math.sin((x - groundOffset * 3 + row * 40) * 0.04 + t + row) * 3;
      if (x === 0) ctx.moveTo(x, wy + wave);
      else ctx.lineTo(x, wy + wave);
    }
    ctx.stroke();
  }

  // Sparkle highlights
  ctx.fillStyle = 'rgba(255, 230, 150, 0.4)';
  for (let i = 0; i < 6; i++) {
    const sx = ((i * 87 + t * 20 + parallaxOffset * 0.5) % W);
    const sy = waterY + 5 + (i * 13) % 40;
    const sparkle = Math.sin(t * 3 + i * 2) * 0.5 + 0.5;
    if (sparkle > 0.7) {
      ctx.globalAlpha = sparkle - 0.5;
      ctx.fillRect(sx, sy, 2, 1);
      ctx.globalAlpha = 1;
    }
  }
}

function drawPilingTexture(x, y, w, h) {
  // Wood grain lines
  ctx.strokeStyle = 'rgba(60, 30, 10, 0.3)';
  ctx.lineWidth = 1;
  for (let gx = x + 6; gx < x + w - 4; gx += 8) {
    ctx.beginPath();
    ctx.moveTo(gx + Math.sin(y * 0.1) * 2, y);
    for (let gy = y; gy < y + h; gy += 10) {
      ctx.lineTo(gx + Math.sin(gy * 0.05) * 2, gy);
    }
    ctx.stroke();
  }
  // Barnacles (small circles near bottom)
  ctx.fillStyle = 'rgba(140, 140, 120, 0.6)';
  for (let i = 0; i < 5; i++) {
    const bx = x + 8 + ((i * 17 + Math.floor(x)) % (w - 16));
    const by = y + h - 15 - ((i * 23) % 30);
    const br = 2 + (i % 2);
    ctx.beginPath();
    ctx.arc(bx, by, br, 0, Math.PI * 2);
    ctx.fill();
  }
}

// â”€â”€ Habitat Definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const HABITATS = {
  halfmoonbay: {
    key: 'halfmoonbay', name: 'Half Moon Bay', shortName: 'HMB', emoji: 'ðŸŒ…',
    description: 'Sunset over the Pacific â€” warm golds and deep purples',
    drawBackground() { drawBackground(); },
    drawWater() { drawWater(); },
    drawPipeStyle(pipe) {
      // Top piling
      const topGrad = ctx.createLinearGradient(pipe.x, 0, pipe.x + PIPE_WIDTH, 0);
      topGrad.addColorStop(0, '#5c3a1e'); topGrad.addColorStop(0.3, '#8B6914');
      topGrad.addColorStop(0.6, '#7a5a2e'); topGrad.addColorStop(1, '#4a2a10');
      ctx.fillStyle = topGrad;
      ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.topH);
      const capGrad = ctx.createLinearGradient(pipe.x - 4, 0, pipe.x + PIPE_WIDTH + 4, 0);
      capGrad.addColorStop(0, '#6b4420'); capGrad.addColorStop(0.5, '#9a7040'); capGrad.addColorStop(1, '#5a3418');
      ctx.fillStyle = capGrad;
      ctx.fillRect(pipe.x - 4, pipe.topH - 20, PIPE_WIDTH + 8, 20);
      ctx.strokeStyle = '#3a1a08'; ctx.lineWidth = 2;
      ctx.strokeRect(pipe.x, 0, PIPE_WIDTH, pipe.topH);
      ctx.strokeRect(pipe.x - 4, pipe.topH - 20, PIPE_WIDTH + 8, 20);
      drawPilingTexture(pipe.x, 0, PIPE_WIDTH, pipe.topH);
      // Bottom piling
      const bH = H - GROUND_HEIGHT - pipe.bottomY;
      const botGrad = ctx.createLinearGradient(pipe.x, 0, pipe.x + PIPE_WIDTH, 0);
      botGrad.addColorStop(0, '#5c3a1e'); botGrad.addColorStop(0.3, '#8B6914');
      botGrad.addColorStop(0.6, '#7a5a2e'); botGrad.addColorStop(1, '#4a2a10');
      ctx.fillStyle = botGrad;
      ctx.fillRect(pipe.x, pipe.bottomY, PIPE_WIDTH, bH);
      ctx.fillStyle = capGrad;
      ctx.fillRect(pipe.x - 4, pipe.bottomY, PIPE_WIDTH + 8, 20);
      ctx.strokeStyle = '#3a1a08'; ctx.lineWidth = 2;
      ctx.strokeRect(pipe.x, pipe.bottomY, PIPE_WIDTH, bH);
      ctx.strokeRect(pipe.x - 4, pipe.bottomY, PIPE_WIDTH + 8, 20);
      drawPilingTexture(pipe.x, pipe.bottomY, PIPE_WIDTH, bH);
      // Green algae at waterline
      ctx.fillStyle = 'rgba(50, 120, 50, 0.4)';
      const algaeY = H - GROUND_HEIGHT - 8;
      for (let ax = pipe.x + 2; ax < pipe.x + PIPE_WIDTH - 2; ax += 5) {
        const ah = 4 + Math.sin(ax * 0.3) * 3;
        ctx.fillRect(ax, algaeY - ah, 3, ah + 8);
      }
    }
  },

  channelislands: {
    key: 'channelislands', name: 'Channel Islands', shortName: 'Islands', emoji: 'ðŸï¸',
    description: 'Midday sun over turquoise waters and rocky sea stacks',
    drawBackground() {
      // Bright midday blue sky
      const grad = ctx.createLinearGradient(0, 0, 0, H - GROUND_HEIGHT);
      grad.addColorStop(0, '#1a6fc4');
      grad.addColorStop(0.4, '#4da6e8');
      grad.addColorStop(0.7, '#7ec8f0');
      grad.addColorStop(1, '#b0e0f8');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H - GROUND_HEIGHT);
      // Bright sun high in sky
      const sunY = (H - GROUND_HEIGHT) * 0.18;
      const sunGrad = ctx.createRadialGradient(W * 0.5, sunY, 8, W * 0.5, sunY, 100);
      sunGrad.addColorStop(0, 'rgba(255, 255, 220, 0.9)');
      sunGrad.addColorStop(0.3, 'rgba(255, 240, 180, 0.3)');
      sunGrad.addColorStop(1, 'rgba(135, 206, 235, 0)');
      ctx.fillStyle = sunGrad;
      ctx.fillRect(0, 0, W, H - GROUND_HEIGHT);
      ctx.fillStyle = '#fff8d0';
      ctx.beginPath(); ctx.arc(W * 0.5, sunY, 22, 0, Math.PI * 2); ctx.fill();
      // White puffy clouds
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      const cs = parallaxOffset * 0.12;
      for (let i = 0; i < 3; i++) {
        const cx = ((i * 180 + 60 - cs) % (W + 140)) - 70;
        drawCloud(cx, 50 + i * 30, 55 + i * 8, 0.5);
      }
      // Distant island silhouettes
      const hillSpeed = parallaxOffset * 0.2;
      ctx.fillStyle = '#5a7a6a';
      ctx.beginPath(); ctx.moveTo(0, H - GROUND_HEIGHT);
      for (let x = 0; x <= W; x += 2) {
        const h = Math.sin((x + hillSpeed) * 0.006) * 35 + Math.sin((x + hillSpeed) * 0.018) * 18 + 45;
        ctx.lineTo(x, H - GROUND_HEIGHT - h);
      }
      ctx.lineTo(W, H - GROUND_HEIGHT); ctx.closePath(); ctx.fill();
      // Rocky sea stacks (sandstone colored)
      const stackSpeed = parallaxOffset * 0.35;
      ctx.fillStyle = '#c4a060';
      for (let i = 0; i < 3; i++) {
        const sx = ((i * 200 + 100 - stackSpeed) % (W + 120)) - 60;
        const sh = 30 + i * 15;
        ctx.beginPath();
        ctx.moveTo(sx - 12, H - GROUND_HEIGHT);
        ctx.lineTo(sx - 8, H - GROUND_HEIGHT - sh);
        ctx.quadraticCurveTo(sx, H - GROUND_HEIGHT - sh - 8, sx + 8, H - GROUND_HEIGHT - sh);
        ctx.lineTo(sx + 12, H - GROUND_HEIGHT);
        ctx.closePath(); ctx.fill();
        // Guano stains (white streaks)
        ctx.fillStyle = 'rgba(255, 255, 240, 0.5)';
        ctx.fillRect(sx - 3, H - GROUND_HEIGHT - sh + 2, 6, sh * 0.4);
        ctx.fillStyle = '#c4a060';
      }
    },
    drawWater() {
      const waterY = H - GROUND_HEIGHT;
      const wGrad = ctx.createLinearGradient(0, waterY, 0, H);
      wGrad.addColorStop(0, '#20a0b0');
      wGrad.addColorStop(0.4, '#1a8898');
      wGrad.addColorStop(1, '#0e5a68');
      ctx.fillStyle = wGrad;
      ctx.fillRect(0, waterY, W, GROUND_HEIGHT);
      // Turquoise shimmer
      const t = performance.now() * 0.002;
      ctx.strokeStyle = 'rgba(150, 240, 255, 0.3)';
      ctx.lineWidth = 1.5;
      for (let row = 0; row < 3; row++) {
        ctx.beginPath();
        const wy = waterY + 8 + row * 18;
        for (let x = 0; x <= W; x += 3) {
          const wave = Math.sin((x - groundOffset * 3 + row * 40) * 0.04 + t + row) * 3;
          if (x === 0) ctx.moveTo(x, wy + wave); else ctx.lineTo(x, wy + wave);
        }
        ctx.stroke();
      }
    },
    drawPipeStyle(pipe) {
      // Sandstone sea stack obstacles
      const topGrad = ctx.createLinearGradient(pipe.x, 0, pipe.x + PIPE_WIDTH, 0);
      topGrad.addColorStop(0, '#a08040'); topGrad.addColorStop(0.4, '#c4a060');
      topGrad.addColorStop(0.7, '#b89050'); topGrad.addColorStop(1, '#8a6830');
      ctx.fillStyle = topGrad;
      ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.topH);
      // Rough cap
      ctx.fillStyle = '#b89050';
      ctx.fillRect(pipe.x - 4, pipe.topH - 18, PIPE_WIDTH + 8, 18);
      ctx.strokeStyle = '#6a4820'; ctx.lineWidth = 2;
      ctx.strokeRect(pipe.x, 0, PIPE_WIDTH, pipe.topH);
      ctx.strokeRect(pipe.x - 4, pipe.topH - 18, PIPE_WIDTH + 8, 18);
      // Rock texture lines
      ctx.strokeStyle = 'rgba(100, 70, 30, 0.25)'; ctx.lineWidth = 1;
      for (let gy = 10; gy < pipe.topH - 20; gy += 14) {
        ctx.beginPath();
        ctx.moveTo(pipe.x + 3, gy + Math.sin(gy * 0.2) * 2);
        ctx.lineTo(pipe.x + PIPE_WIDTH - 3, gy + Math.sin(gy * 0.15) * 3);
        ctx.stroke();
      }
      // Guano stains on top
      ctx.fillStyle = 'rgba(255, 255, 240, 0.35)';
      ctx.fillRect(pipe.x + 8, pipe.topH - 30, 12, 20);
      ctx.fillRect(pipe.x + 30, pipe.topH - 25, 10, 15);
      // Bottom
      const bH = H - GROUND_HEIGHT - pipe.bottomY;
      ctx.fillStyle = topGrad;
      ctx.fillRect(pipe.x, pipe.bottomY, PIPE_WIDTH, bH);
      ctx.fillStyle = '#b89050';
      ctx.fillRect(pipe.x - 4, pipe.bottomY, PIPE_WIDTH + 8, 18);
      ctx.strokeStyle = '#6a4820'; ctx.lineWidth = 2;
      ctx.strokeRect(pipe.x, pipe.bottomY, PIPE_WIDTH, bH);
      ctx.strokeRect(pipe.x - 4, pipe.bottomY, PIPE_WIDTH + 8, 18);
      for (let gy = pipe.bottomY + 22; gy < H - GROUND_HEIGHT; gy += 14) {
        ctx.strokeStyle = 'rgba(100, 70, 30, 0.25)'; ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(pipe.x + 3, gy + Math.sin(gy * 0.2) * 2);
        ctx.lineTo(pipe.x + PIPE_WIDTH - 3, gy + Math.sin(gy * 0.15) * 3);
        ctx.stroke();
      }
    }
  },

  lajolla: {
    key: 'lajolla', name: 'La Jolla Cove', shortName: 'La Jolla', emoji: 'ðŸŒŠ',
    description: 'Morning light over clear blue-green water with kelp forests',
    drawBackground() {
      // Morning blue sky
      const grad = ctx.createLinearGradient(0, 0, 0, H - GROUND_HEIGHT);
      grad.addColorStop(0, '#2a5ca8');
      grad.addColorStop(0.3, '#5a9ad8');
      grad.addColorStop(0.6, '#8ac4e8');
      grad.addColorStop(1, '#c8e8f8');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H - GROUND_HEIGHT);
      // Morning sun (low, east side)
      const sunY = (H - GROUND_HEIGHT) * 0.35;
      const sunGrad = ctx.createRadialGradient(W * 0.85, sunY, 8, W * 0.85, sunY, 90);
      sunGrad.addColorStop(0, 'rgba(255, 240, 200, 0.7)');
      sunGrad.addColorStop(0.4, 'rgba(255, 220, 160, 0.2)');
      sunGrad.addColorStop(1, 'rgba(135, 200, 235, 0)');
      ctx.fillStyle = sunGrad;
      ctx.fillRect(0, 0, W, H - GROUND_HEIGHT);
      // Wispy clouds
      const cs = parallaxOffset * 0.1;
      for (let i = 0; i < 3; i++) {
        const cx = ((i * 190 + 30 - cs) % (W + 140)) - 70;
        drawCloud(cx, 40 + i * 35, 45 + i * 10, 0.35);
      }
      // Coastal cliffs
      const hillSpeed = parallaxOffset * 0.25;
      ctx.fillStyle = '#8a7a60';
      ctx.beginPath(); ctx.moveTo(0, H - GROUND_HEIGHT);
      for (let x = 0; x <= W; x += 2) {
        const h = Math.sin((x + hillSpeed) * 0.007) * 30 + Math.sin((x + hillSpeed) * 0.022) * 15 + 40;
        ctx.lineTo(x, H - GROUND_HEIGHT - h);
      }
      ctx.lineTo(W, H - GROUND_HEIGHT); ctx.closePath(); ctx.fill();
      // Green vegetation on cliffs
      ctx.fillStyle = '#4a7a3a';
      ctx.beginPath(); ctx.moveTo(0, H - GROUND_HEIGHT);
      for (let x = 0; x <= W; x += 2) {
        const h = Math.sin((x + hillSpeed) * 0.007) * 28 + Math.sin((x + hillSpeed) * 0.022) * 12 + 32;
        ctx.lineTo(x, H - GROUND_HEIGHT - h);
      }
      ctx.lineTo(W, H - GROUND_HEIGHT); ctx.closePath(); ctx.fill();
    },
    drawWater() {
      const waterY = H - GROUND_HEIGHT;
      const wGrad = ctx.createLinearGradient(0, waterY, 0, H);
      wGrad.addColorStop(0, '#2a8a7a');
      wGrad.addColorStop(0.3, '#1a6a60');
      wGrad.addColorStop(1, '#0a4a40');
      ctx.fillStyle = wGrad;
      ctx.fillRect(0, waterY, W, GROUND_HEIGHT);
      // Kelp fronds floating on surface
      const t = performance.now() * 0.002;
      ctx.fillStyle = 'rgba(60, 100, 40, 0.4)';
      for (let i = 0; i < 8; i++) {
        const kx = ((i * 67 + parallaxOffset * 0.4) % W);
        const ky = waterY + 3 + Math.sin(t + i) * 2;
        ctx.beginPath();
        ctx.ellipse(kx, ky, 8 + (i % 3) * 3, 2, Math.sin(t + i * 0.5) * 0.3, 0, Math.PI * 2);
        ctx.fill();
      }
      // Waves
      ctx.strokeStyle = 'rgba(100, 200, 200, 0.3)';
      ctx.lineWidth = 1.5;
      for (let row = 0; row < 3; row++) {
        ctx.beginPath();
        const wy = waterY + 8 + row * 18;
        for (let x = 0; x <= W; x += 3) {
          const wave = Math.sin((x - groundOffset * 3 + row * 40) * 0.04 + t + row) * 3;
          if (x === 0) ctx.moveTo(x, wy + wave); else ctx.lineTo(x, wy + wave);
        }
        ctx.stroke();
      }
    },
    drawPipeStyle(pipe) {
      // Kelp stalk obstacles â€” dark green-brown
      const topGrad = ctx.createLinearGradient(pipe.x, 0, pipe.x + PIPE_WIDTH, 0);
      topGrad.addColorStop(0, '#3a5a30'); topGrad.addColorStop(0.4, '#4a7040');
      topGrad.addColorStop(0.7, '#3a6035'); topGrad.addColorStop(1, '#2a4a20');
      ctx.fillStyle = topGrad;
      ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.topH);
      // Kelp bulb cap
      ctx.fillStyle = '#5a8a40';
      ctx.beginPath();
      ctx.ellipse(pipe.x + PIPE_WIDTH / 2, pipe.topH - 6, PIPE_WIDTH / 2 + 4, 12, 0, 0, Math.PI);
      ctx.fill();
      ctx.strokeStyle = '#2a4a18'; ctx.lineWidth = 2;
      ctx.strokeRect(pipe.x, 0, PIPE_WIDTH, pipe.topH);
      // Kelp texture â€” wavy vertical lines
      ctx.strokeStyle = 'rgba(30, 60, 20, 0.3)'; ctx.lineWidth = 1;
      for (let gx = pipe.x + 8; gx < pipe.x + PIPE_WIDTH - 6; gx += 10) {
        ctx.beginPath();
        for (let gy = 0; gy < pipe.topH; gy += 6) {
          const wx = gx + Math.sin(gy * 0.08 + gx * 0.1) * 3;
          if (gy === 0) ctx.moveTo(wx, gy); else ctx.lineTo(wx, gy);
        }
        ctx.stroke();
      }
      // Small leaf blades on sides
      ctx.fillStyle = 'rgba(80, 130, 50, 0.5)';
      for (let i = 0; i < 4; i++) {
        const ly = pipe.topH * (0.2 + i * 0.2);
        const side = i % 2 === 0 ? -1 : 1;
        const lx = side > 0 ? pipe.x + PIPE_WIDTH : pipe.x;
        ctx.beginPath();
        ctx.moveTo(lx, ly);
        ctx.quadraticCurveTo(lx + side * 12, ly - 4, lx + side * 8, ly + 6);
        ctx.quadraticCurveTo(lx + side * 4, ly + 3, lx, ly);
        ctx.fill();
      }
      // Bottom kelp stalk
      const bH = H - GROUND_HEIGHT - pipe.bottomY;
      ctx.fillStyle = topGrad;
      ctx.fillRect(pipe.x, pipe.bottomY, PIPE_WIDTH, bH);
      ctx.fillStyle = '#5a8a40';
      ctx.beginPath();
      ctx.ellipse(pipe.x + PIPE_WIDTH / 2, pipe.bottomY + 6, PIPE_WIDTH / 2 + 4, 12, 0, Math.PI, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#2a4a18'; ctx.lineWidth = 2;
      ctx.strokeRect(pipe.x, pipe.bottomY, PIPE_WIDTH, bH);
      for (let gx = pipe.x + 8; gx < pipe.x + PIPE_WIDTH - 6; gx += 10) {
        ctx.strokeStyle = 'rgba(30, 60, 20, 0.3)'; ctx.lineWidth = 1;
        ctx.beginPath();
        for (let gy = pipe.bottomY; gy < H - GROUND_HEIGHT; gy += 6) {
          const wx = gx + Math.sin(gy * 0.08 + gx * 0.1) * 3;
          if (gy === pipe.bottomY) ctx.moveTo(wx, gy); else ctx.lineTo(wx, gy);
        }
        ctx.stroke();
      }
    }
  },

  morrobay: {
    key: 'morrobay', name: 'Morro Bay', shortName: 'Morro', emoji: 'ðŸŒ',
    description: 'Foggy harbor with Morro Rock silhouette and dock pilings',
    drawBackground() {
      // Foggy gray sky
      const grad = ctx.createLinearGradient(0, 0, 0, H - GROUND_HEIGHT);
      grad.addColorStop(0, '#8a9aaa');
      grad.addColorStop(0.3, '#a0b0b8');
      grad.addColorStop(0.6, '#b8c4c8');
      grad.addColorStop(1, '#c8d0d4');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H - GROUND_HEIGHT);
      // Diffused sun behind fog
      const sunY = (H - GROUND_HEIGHT) * 0.3;
      const sunGrad = ctx.createRadialGradient(W * 0.6, sunY, 15, W * 0.6, sunY, 100);
      sunGrad.addColorStop(0, 'rgba(220, 220, 210, 0.5)');
      sunGrad.addColorStop(0.5, 'rgba(200, 210, 215, 0.2)');
      sunGrad.addColorStop(1, 'rgba(180, 195, 200, 0)');
      ctx.fillStyle = sunGrad;
      ctx.fillRect(0, 0, W, H - GROUND_HEIGHT);
      // Morro Rock silhouette (large, iconic)
      const rockSpeed = parallaxOffset * 0.15;
      const rockX = ((W * 0.35 - rockSpeed) % (W + 300)) - 100;
      ctx.fillStyle = '#5a6068';
      ctx.beginPath();
      ctx.moveTo(rockX - 60, H - GROUND_HEIGHT);
      ctx.quadraticCurveTo(rockX - 40, H - GROUND_HEIGHT - 80, rockX, H - GROUND_HEIGHT - 110);
      ctx.quadraticCurveTo(rockX + 40, H - GROUND_HEIGHT - 80, rockX + 60, H - GROUND_HEIGHT);
      ctx.closePath(); ctx.fill();
      // Fog wisps
      ctx.fillStyle = 'rgba(200, 210, 215, 0.3)';
      const fogSpeed = parallaxOffset * 0.08;
      for (let i = 0; i < 4; i++) {
        const fx = ((i * 150 + 30 - fogSpeed) % (W + 200)) - 100;
        const fy = (H - GROUND_HEIGHT) * (0.4 + i * 0.12);
        ctx.beginPath();
        ctx.ellipse(fx, fy, 80 + i * 20, 8 + i * 3, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      // Distant harbor buildings
      const hillSpeed = parallaxOffset * 0.2;
      ctx.fillStyle = '#6a7078';
      ctx.beginPath(); ctx.moveTo(0, H - GROUND_HEIGHT);
      for (let x = 0; x <= W; x += 2) {
        const h = Math.sin((x + hillSpeed) * 0.01) * 20 + Math.sin((x + hillSpeed) * 0.025) * 10 + 25;
        ctx.lineTo(x, H - GROUND_HEIGHT - h);
      }
      ctx.lineTo(W, H - GROUND_HEIGHT); ctx.closePath(); ctx.fill();
    },
    drawWater() {
      const waterY = H - GROUND_HEIGHT;
      const wGrad = ctx.createLinearGradient(0, waterY, 0, H);
      wGrad.addColorStop(0, '#5a7080');
      wGrad.addColorStop(0.3, '#4a6070');
      wGrad.addColorStop(1, '#3a4a58');
      ctx.fillStyle = wGrad;
      ctx.fillRect(0, waterY, W, GROUND_HEIGHT);
      // Calm harbor waves (subtle)
      const t = performance.now() * 0.002;
      ctx.strokeStyle = 'rgba(140, 170, 190, 0.2)';
      ctx.lineWidth = 1;
      for (let row = 0; row < 3; row++) {
        ctx.beginPath();
        const wy = waterY + 10 + row * 16;
        for (let x = 0; x <= W; x += 4) {
          const wave = Math.sin((x - groundOffset * 2 + row * 50) * 0.03 + t + row) * 2;
          if (x === 0) ctx.moveTo(x, wy + wave); else ctx.lineTo(x, wy + wave);
        }
        ctx.stroke();
      }
    },
    drawPipeStyle(pipe) {
      // Gray dock pilings with rope
      const topGrad = ctx.createLinearGradient(pipe.x, 0, pipe.x + PIPE_WIDTH, 0);
      topGrad.addColorStop(0, '#5a5a5a'); topGrad.addColorStop(0.3, '#787878');
      topGrad.addColorStop(0.6, '#6a6a6a'); topGrad.addColorStop(1, '#4a4a4a');
      ctx.fillStyle = topGrad;
      ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.topH);
      // Metal cap/band
      ctx.fillStyle = '#606868';
      ctx.fillRect(pipe.x - 3, pipe.topH - 16, PIPE_WIDTH + 6, 16);
      ctx.strokeStyle = '#3a3a3a'; ctx.lineWidth = 2;
      ctx.strokeRect(pipe.x, 0, PIPE_WIDTH, pipe.topH);
      ctx.strokeRect(pipe.x - 3, pipe.topH - 16, PIPE_WIDTH + 6, 16);
      // Rope wrapped around piling
      ctx.strokeStyle = '#a09070'; ctx.lineWidth = 2;
      for (let ry = 20; ry < pipe.topH - 20; ry += 28) {
        ctx.beginPath();
        ctx.moveTo(pipe.x, ry);
        ctx.quadraticCurveTo(pipe.x + PIPE_WIDTH / 2, ry - 6, pipe.x + PIPE_WIDTH, ry);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(pipe.x, ry + 8);
        ctx.quadraticCurveTo(pipe.x + PIPE_WIDTH / 2, ry + 14, pipe.x + PIPE_WIDTH, ry + 8);
        ctx.stroke();
      }
      // Bottom piling
      const bH = H - GROUND_HEIGHT - pipe.bottomY;
      ctx.fillStyle = topGrad;
      ctx.fillRect(pipe.x, pipe.bottomY, PIPE_WIDTH, bH);
      ctx.fillStyle = '#606868';
      ctx.fillRect(pipe.x - 3, pipe.bottomY, PIPE_WIDTH + 6, 16);
      ctx.strokeStyle = '#3a3a3a'; ctx.lineWidth = 2;
      ctx.strokeRect(pipe.x, pipe.bottomY, PIPE_WIDTH, bH);
      ctx.strokeRect(pipe.x - 3, pipe.bottomY, PIPE_WIDTH + 6, 16);
      // Rope on bottom
      for (let ry = pipe.bottomY + 20; ry < H - GROUND_HEIGHT - 10; ry += 28) {
        ctx.strokeStyle = '#a09070'; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(pipe.x, ry);
        ctx.quadraticCurveTo(pipe.x + PIPE_WIDTH / 2, ry - 6, pipe.x + PIPE_WIDTH, ry);
        ctx.stroke();
      }
    }
  },

  bolsachica: {
    key: 'bolsachica', name: 'Bolsa Chica Wetlands', shortName: 'Bolsa', emoji: 'ðŸŒ¿',
    description: 'Golden afternoon over murky estuary with boardwalk pilings',
    drawBackground() {
      // Golden afternoon sky
      const grad = ctx.createLinearGradient(0, 0, 0, H - GROUND_HEIGHT);
      grad.addColorStop(0, '#4a6a90');
      grad.addColorStop(0.3, '#8aa0b0');
      grad.addColorStop(0.5, '#c8b888');
      grad.addColorStop(0.75, '#d8c888');
      grad.addColorStop(1, '#e8d8a0');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H - GROUND_HEIGHT);
      // Warm sun
      const sunY = (H - GROUND_HEIGHT) * 0.45;
      const sunGrad = ctx.createRadialGradient(W * 0.65, sunY, 10, W * 0.65, sunY, 100);
      sunGrad.addColorStop(0, 'rgba(255, 230, 140, 0.6)');
      sunGrad.addColorStop(0.4, 'rgba(255, 210, 100, 0.2)');
      sunGrad.addColorStop(1, 'rgba(200, 180, 120, 0)');
      ctx.fillStyle = sunGrad;
      ctx.fillRect(0, 0, W, H - GROUND_HEIGHT);
      // Distant marsh/wetland vegetation
      const hillSpeed = parallaxOffset * 0.2;
      ctx.fillStyle = '#6a8a50';
      ctx.beginPath(); ctx.moveTo(0, H - GROUND_HEIGHT);
      for (let x = 0; x <= W; x += 2) {
        const h = Math.sin((x + hillSpeed) * 0.01) * 15 + Math.sin((x + hillSpeed) * 0.03) * 8 + 20;
        ctx.lineTo(x, H - GROUND_HEIGHT - h);
      }
      ctx.lineTo(W, H - GROUND_HEIGHT); ctx.closePath(); ctx.fill();
      // Cattails in foreground
      const cattailSpeed = parallaxOffset * 0.4;
      ctx.strokeStyle = '#4a6030';
      ctx.lineWidth = 2;
      for (let i = 0; i < 6; i++) {
        const cx = ((i * 90 + 40 - cattailSpeed) % (W + 80)) - 40;
        const ch = 35 + (i % 3) * 10;
        const sway = Math.sin(performance.now() * 0.001 + i) * 3;
        // Stem
        ctx.beginPath();
        ctx.moveTo(cx, H - GROUND_HEIGHT);
        ctx.quadraticCurveTo(cx + sway, H - GROUND_HEIGHT - ch / 2, cx + sway * 1.5, H - GROUND_HEIGHT - ch);
        ctx.stroke();
        // Brown cattail head
        ctx.fillStyle = '#6a4020';
        ctx.beginPath();
        ctx.ellipse(cx + sway * 1.5, H - GROUND_HEIGHT - ch - 5, 3, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#4a6030'; ctx.lineWidth = 2;
      }
    },
    drawWater() {
      const waterY = H - GROUND_HEIGHT;
      const wGrad = ctx.createLinearGradient(0, waterY, 0, H);
      wGrad.addColorStop(0, '#5a7050');
      wGrad.addColorStop(0.3, '#4a5a3a');
      wGrad.addColorStop(1, '#3a4a2a');
      ctx.fillStyle = wGrad;
      ctx.fillRect(0, waterY, W, GROUND_HEIGHT);
      // Murky estuary â€” subtle ripples
      const t = performance.now() * 0.002;
      ctx.strokeStyle = 'rgba(120, 140, 100, 0.25)';
      ctx.lineWidth = 1;
      for (let row = 0; row < 3; row++) {
        ctx.beginPath();
        const wy = waterY + 8 + row * 18;
        for (let x = 0; x <= W; x += 4) {
          const wave = Math.sin((x - groundOffset * 2 + row * 50) * 0.03 + t + row) * 2;
          if (x === 0) ctx.moveTo(x, wy + wave); else ctx.lineTo(x, wy + wave);
        }
        ctx.stroke();
      }
    },
    drawPipeStyle(pipe) {
      // Boardwalk pilings â€” weathered wood with signs
      const topGrad = ctx.createLinearGradient(pipe.x, 0, pipe.x + PIPE_WIDTH, 0);
      topGrad.addColorStop(0, '#7a6a50'); topGrad.addColorStop(0.3, '#9a8a68');
      topGrad.addColorStop(0.6, '#8a7a58'); topGrad.addColorStop(1, '#6a5a40');
      ctx.fillStyle = topGrad;
      ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.topH);
      // Boardwalk plank cap
      ctx.fillStyle = '#8a7a58';
      ctx.fillRect(pipe.x - 5, pipe.topH - 18, PIPE_WIDTH + 10, 18);
      // Plank lines on cap
      ctx.strokeStyle = 'rgba(80, 60, 30, 0.3)'; ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pipe.x - 5, pipe.topH - 9);
      ctx.lineTo(pipe.x + PIPE_WIDTH + 5, pipe.topH - 9);
      ctx.stroke();
      ctx.strokeStyle = '#5a4a30'; ctx.lineWidth = 2;
      ctx.strokeRect(pipe.x, 0, PIPE_WIDTH, pipe.topH);
      ctx.strokeRect(pipe.x - 5, pipe.topH - 18, PIPE_WIDTH + 10, 18);
      drawPilingTexture(pipe.x, 0, PIPE_WIDTH, pipe.topH);
      // Small sign on some pilings
      if (Math.floor(pipe.x) % 3 === 0) {
        ctx.fillStyle = '#e8d8b0';
        ctx.fillRect(pipe.x + 8, pipe.topH - 50, PIPE_WIDTH - 16, 22);
        ctx.strokeStyle = '#6a5a30'; ctx.lineWidth = 1;
        ctx.strokeRect(pipe.x + 8, pipe.topH - 50, PIPE_WIDTH - 16, 22);
        ctx.fillStyle = '#4a3a20';
        ctx.font = 'bold 7px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('WILDLIFE', pipe.x + PIPE_WIDTH / 2, pipe.topH - 38);
        ctx.fillText('RESERVE', pipe.x + PIPE_WIDTH / 2, pipe.topH - 31);
      }
      // Bottom piling
      const bH = H - GROUND_HEIGHT - pipe.bottomY;
      ctx.fillStyle = topGrad;
      ctx.fillRect(pipe.x, pipe.bottomY, PIPE_WIDTH, bH);
      ctx.fillStyle = '#8a7a58';
      ctx.fillRect(pipe.x - 5, pipe.bottomY, PIPE_WIDTH + 10, 18);
      ctx.strokeStyle = 'rgba(80, 60, 30, 0.3)'; ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pipe.x - 5, pipe.bottomY + 9);
      ctx.lineTo(pipe.x + PIPE_WIDTH + 5, pipe.bottomY + 9);
      ctx.stroke();
      ctx.strokeStyle = '#5a4a30'; ctx.lineWidth = 2;
      ctx.strokeRect(pipe.x, pipe.bottomY, PIPE_WIDTH, bH);
      ctx.strokeRect(pipe.x - 5, pipe.bottomY, PIPE_WIDTH + 10, 18);
      drawPilingTexture(pipe.x, pipe.bottomY, PIPE_WIDTH, bH);
    }
  }
};

// Validate habitat on load
if (!HABITATS[currentHabitat]) currentHabitat = 'halfmoonbay';

function drawSimon(pipe) {
  ctx.save();
  pipe.simonFrame++;
  const f = pipe.simonFrame;
  // Pop-up animation: slide up over first 20 frames
  const popProgress = Math.min(f / 20, 1);
  const simonHeight = 80; // total visible height of Simon
  const peekX = pipe.x + PIPE_WIDTH + 2; // right edge of piling
  const capTop = pipe.bottomY; // top of bottom piling cap
  const baseY = capTop + simonHeight; // hidden position
  const simonY = baseY - (simonHeight * popProgress); // slide up

  // Clip so Simon doesn't draw below the piling cap top area
  ctx.beginPath();
  ctx.rect(peekX - 30, capTop - simonHeight - 10, 80, simonHeight + 10);
  ctx.clip();

  const cx = peekX; // center x of Simon
  const cy = simonY;

  // â”€â”€ Blue T-shirt â”€â”€
  ctx.fillStyle = '#3b82f6';
  ctx.beginPath();
  ctx.moveTo(cx - 18, cy + 10);
  ctx.lineTo(cx + 18, cy + 10);
  ctx.lineTo(cx + 20, cy + 45);
  ctx.lineTo(cx - 20, cy + 45);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = '#2563eb';
  ctx.lineWidth = 1;
  ctx.stroke();

  // â”€â”€ Neck â”€â”€
  ctx.fillStyle = '#f0c8a0';
  ctx.fillRect(cx - 5, cy + 2, 10, 12);

  // â”€â”€ Head (round face) â”€â”€
  ctx.fillStyle = '#f0c8a0';
  ctx.beginPath();
  ctx.arc(cx, cy - 10, 16, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#d4a574';
  ctx.lineWidth = 1;
  ctx.stroke();

  // â”€â”€ Short messy brown hair â”€â”€
  ctx.fillStyle = '#5c3317';
  ctx.beginPath();
  ctx.arc(cx, cy - 14, 16, Math.PI, 0);
  ctx.fill();
  // Messy tufts
  ctx.beginPath();
  ctx.ellipse(cx - 10, cy - 26, 5, 6, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(cx + 2, cy - 28, 5, 5, 0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(cx + 11, cy - 24, 4, 5, 0.4, 0, Math.PI * 2);
  ctx.fill();

  // â”€â”€ Wire-frame glasses â”€â”€
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 1.5;
  // Left lens
  ctx.beginPath();
  ctx.arc(cx - 7, cy - 10, 6, 0, Math.PI * 2);
  ctx.stroke();
  // Right lens
  ctx.beginPath();
  ctx.arc(cx + 7, cy - 10, 6, 0, Math.PI * 2);
  ctx.stroke();
  // Bridge
  ctx.beginPath();
  ctx.moveTo(cx - 1, cy - 10);
  ctx.lineTo(cx + 1, cy - 10);
  ctx.stroke();
  // Temples
  ctx.beginPath();
  ctx.moveTo(cx - 13, cy - 10);
  ctx.lineTo(cx - 16, cy - 12);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(cx + 13, cy - 10);
  ctx.lineTo(cx + 16, cy - 12);
  ctx.stroke();

  // â”€â”€ Eyes (behind glasses) â”€â”€
  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.arc(cx - 7, cy - 10, 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(cx + 7, cy - 10, 2, 0, Math.PI * 2);
  ctx.fill();

  // â”€â”€ Big friendly smile â”€â”€
  ctx.strokeStyle = '#c0705a';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(cx, cy - 3, 8, 0.15, Math.PI - 0.15);
  ctx.stroke();

  // â”€â”€ Waving hand (right side, oscillates with sin) â”€â”€
  const waveAngle = Math.sin(f * 0.15) * 0.4;
  ctx.save();
  ctx.translate(cx + 20, cy + 15);
  ctx.rotate(-0.8 + waveAngle);
  // Arm
  ctx.strokeStyle = '#f0c8a0';
  ctx.lineWidth = 5;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(0, -20);
  ctx.stroke();
  // Hand
  ctx.fillStyle = '#f0c8a0';
  ctx.beginPath();
  ctx.arc(0, -22, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // â”€â”€ Left hand holding sign â”€â”€
  ctx.save();
  ctx.translate(cx - 22, cy + 12);
  // Arm
  ctx.strokeStyle = '#f0c8a0';
  ctx.lineWidth = 5;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-5, -18);
  ctx.stroke();
  // Hand
  ctx.fillStyle = '#f0c8a0';
  ctx.beginPath();
  ctx.arc(-5, -20, 4, 0, Math.PI * 2);
  ctx.fill();
  // Sign
  ctx.fillStyle = '#fff';
  ctx.fillRect(-28, -42, 48, 20);
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 1;
  ctx.strokeRect(-28, -42, 48, 20);
  // Sign text: "I â¤ï¸ Pelicans"
  ctx.fillStyle = '#333';
  ctx.font = 'bold 8px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('I', -20, -32);
  ctx.fillStyle = '#e74c3c';
  ctx.fillText('â¤', -13, -32);
  ctx.fillStyle = '#333';
  ctx.fillText('Pelicans', 5, -32);
  // Sign stick
  ctx.strokeStyle = '#8B6914';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-4, -22);
  ctx.lineTo(-4, -42);
  ctx.stroke();
  ctx.restore();

  ctx.restore();
}

function drawFish(pipe) {
  const fx = pipe.x + PIPE_WIDTH / 2;
  const baseY = pipe.fish.y;
  const osc = Math.sin(performance.now() / 200 + pipe.x) * 3;
  const fy = baseY + osc;
  const type = pipe.fish.type;

  ctx.save();
  ctx.translate(fx, fy);

  let bodyW, bodyH, bodyColor1, bodyColor2;
  if (type === 'anchovy') {
    bodyW = 12; bodyH = 5;
    bodyColor1 = '#c0c0c0'; bodyColor2 = '#808080';
  } else if (type === 'sardine') {
    bodyW = 16; bodyH = 6;
    bodyColor1 = '#a0b8d0'; bodyColor2 = '#6080a0';
  } else { // smelt
    bodyW = 14; bodyH = 5;
    bodyColor1 = '#b0c8a8'; bodyColor2 = '#80a078';
  }

  // Body (oval with gradient) â€” fish faces LEFT
  const grad = ctx.createLinearGradient(0, -bodyH, 0, bodyH);
  grad.addColorStop(0, bodyColor1);
  grad.addColorStop(1, bodyColor2);
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.ellipse(0, 0, bodyW / 2, bodyH / 2, 0, 0, Math.PI * 2);
  ctx.fill();

  // Tail fin (triangle on the RIGHT since fish faces left)
  ctx.fillStyle = bodyColor2;
  ctx.beginPath();
  ctx.moveTo(bodyW / 2 - 1, 0);
  ctx.lineTo(bodyW / 2 + 4, -3);
  ctx.lineTo(bodyW / 2 + 4, 3);
  ctx.closePath();
  ctx.fill();

  // Eye (dot on the LEFT side since fish faces left)
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(-bodyW / 4, -1, 1, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawScorePopups() {
  for (const p of scorePopups) {
    ctx.save();
    ctx.globalAlpha = p.alpha;
    ctx.font = 'bold 22px "Georgia", serif';
    ctx.textAlign = 'center';
    ctx.strokeStyle = '#2a1a00';
    ctx.lineWidth = 3;
    ctx.strokeText('+3', p.x, p.y);
    ctx.fillStyle = '#FFD700';
    ctx.fillText('+3', p.x, p.y);
    ctx.restore();
  }
}

function drawPipes() {
  const habitat = getHabitat();
  for (const pipe of pipes) {
    // Use habitat-specific pipe style (visual only â€” same hitbox)
    habitat.drawPipeStyle(pipe);

    // Fish collectible in the gap
    if (pipe.fish && !pipe.fish.collected) {
      drawFish(pipe);
    }

    // Simon Willison easter egg
    if (pipe.hasSimon) {
      drawSimon(pipe);
    }
  }
}

function drawPelican() {
  ctx.save();
  ctx.translate(PELICAN_X + PELICAN_W / 2, pelican.y + PELICAN_H / 2);
  ctx.rotate(pelican.rotation);

  const hw = PELICAN_W / 2, hh = PELICAN_H / 2;
  const flapping = pelican.flapTimer > 0;
  const wp = pelican.wingPhase;
  const pouchSway = Math.sin(wp * 1.3) * 1.2;

  // â”€â”€ 1. Tail feathers â€” dark brown wedge fan â”€â”€
  ctx.fillStyle = '#3a2818';
  ctx.beginPath();
  ctx.moveTo(-hw - 1, -3);
  ctx.lineTo(-hw - 14, -8);
  ctx.lineTo(-hw - 16, -4);
  ctx.lineTo(-hw - 17, 0);
  ctx.lineTo(-hw - 16, 4);
  ctx.lineTo(-hw - 14, 7);
  ctx.lineTo(-hw - 1, 3);
  ctx.closePath();
  ctx.fill();
  // Individual feather lines
  ctx.strokeStyle = '#2a1a0a';
  ctx.lineWidth = 0.5;
  for (let i = -2; i <= 2; i++) {
    ctx.beginPath();
    ctx.moveTo(-hw - 1, i * 1.2);
    ctx.lineTo(-hw - 15, i * 3.2);
    ctx.stroke();
  }

  // â”€â”€ 2. Body â€” dark upper, cream belly â”€â”€
  // Upper body (dark grayish-brown)
  ctx.fillStyle = '#4a3828';
  ctx.beginPath();
  ctx.ellipse(0, 0, hw + 2, hh, 0, 0, Math.PI * 2);
  ctx.fill();
  // Belly (cream-white, lower half)
  ctx.save();
  ctx.beginPath();
  ctx.rect(-hw - 4, 0, (hw + 4) * 2, hh + 4);
  ctx.clip();
  ctx.fillStyle = '#F0E8D8';
  ctx.beginPath();
  ctx.ellipse(0, 2, hw, hh - 2, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
  // Subtle gradient transition on body
  ctx.fillStyle = 'rgba(90, 72, 56, 0.25)';
  ctx.beginPath();
  ctx.ellipse(0, -4, hw - 2, hh - 6, 0, 0, Math.PI * 2);
  ctx.fill();

  // â”€â”€ 3. Wing (animated, layered feathers) â”€â”€
  let wingAngle = 0;
  let wingSpread = 0;
  if (flapping) {
    wingAngle = -0.35 - Math.sin(pelican.flapTimer * 0.8) * 0.4;
    wingSpread = 0.5 + Math.sin(pelican.flapTimer * 0.8) * 0.5;
  } else {
    wingAngle = 0.05 + Math.sin(wp) * 0.06;
    wingSpread = 0;
  }
  ctx.save();
  ctx.translate(-4, -4);
  ctx.rotate(wingAngle);
  // Wing coverts (silvery gray-brown base)
  ctx.fillStyle = '#8a8070';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.quadraticCurveTo(8, -10 - wingSpread * 6, 18, -4 - wingSpread * 4);
  ctx.quadraticCurveTo(10, 4, 0, 5);
  ctx.closePath();
  ctx.fill();
  // Brown streaks on coverts
  ctx.strokeStyle = 'rgba(74, 56, 40, 0.4)';
  ctx.lineWidth = 0.6;
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.moveTo(2 + i * 3, 1 - i);
    ctx.quadraticCurveTo(8 + i * 2, -4 - i * 2 - wingSpread * 3, 14 + i, -2 - i - wingSpread * 2);
    ctx.stroke();
  }
  // Secondary feathers (gray with lighter edges)
  ctx.fillStyle = '#6a6258';
  ctx.beginPath();
  ctx.moveTo(4, 2);
  ctx.quadraticCurveTo(14, -8 - wingSpread * 5, 22, -2 - wingSpread * 3);
  ctx.quadraticCurveTo(14, 6, 4, 6);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = 'rgba(180, 170, 155, 0.5)';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(10, -2 - wingSpread * 2);
  ctx.quadraticCurveTo(16, -5 - wingSpread * 4, 22, -2 - wingSpread * 3);
  ctx.stroke();
  // Primary feathers (dark brown/black, fan out during flap)
  ctx.fillStyle = '#2a2018';
  const primaries = 4;
  for (let i = 0; i < primaries; i++) {
    const spread = wingSpread * (i - 1.5) * 0.12;
    const len = 10 + i * 2;
    const baseX = 14 + i * 2;
    const baseY = -1 - wingSpread * 2 - i * 0.5;
    ctx.beginPath();
    ctx.moveTo(baseX, baseY);
    ctx.lineTo(baseX + len, baseY - 4 - wingSpread * 4 + spread * 8);
    ctx.lineTo(baseX + len - 1.5, baseY - 2 - wingSpread * 3 + spread * 8);
    ctx.lineTo(baseX - 1, baseY + 1.5);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();

  // â”€â”€ 4. S-curved neck â”€â”€
  // Neck back (chestnut/mahogany nape)
  const neckBaseX = hw - 6;
  const neckBaseY = -hh + 4;
  const neckTopX = hw + 3;
  const neckTopY = -hh - 12;
  ctx.fillStyle = '#6B2A0A';
  ctx.beginPath();
  ctx.moveTo(neckBaseX - 2, neckBaseY);
  ctx.bezierCurveTo(neckBaseX + 6, neckBaseY - 6, neckTopX + 4, neckTopY + 8, neckTopX + 2, neckTopY + 2);
  ctx.lineTo(neckTopX - 2, neckTopY + 2);
  ctx.bezierCurveTo(neckTopX, neckTopY + 8, neckBaseX + 2, neckBaseY - 4, neckBaseX - 6, neckBaseY + 2);
  ctx.closePath();
  ctx.fill();
  // Neck front (cream)
  ctx.fillStyle = '#F5E6C8';
  ctx.beginPath();
  ctx.moveTo(neckBaseX - 5, neckBaseY + 1);
  ctx.bezierCurveTo(neckBaseX, neckBaseY - 6, neckTopX - 1, neckTopY + 10, neckTopX - 3, neckTopY + 3);
  ctx.lineTo(neckTopX - 1, neckTopY + 3);
  ctx.bezierCurveTo(neckTopX + 1, neckTopY + 10, neckBaseX + 2, neckBaseY - 3, neckBaseX - 3, neckBaseY + 3);
  ctx.closePath();
  ctx.fill();

  // â”€â”€ 5. Head â”€â”€
  const headX = hw + 2;
  const headY = -hh - 14;
  const headR = 6.5;
  // Head base (cream-white)
  ctx.fillStyle = '#FFF8E7';
  ctx.beginPath();
  ctx.arc(headX, headY, headR, 0, Math.PI * 2);
  ctx.fill();
  // Golden-yellow crown patch
  ctx.fillStyle = '#D4A017';
  ctx.beginPath();
  ctx.arc(headX - 1, headY - 3, 5, Math.PI * 1.1, Math.PI * 1.95, true);
  ctx.quadraticCurveTo(headX - 1, headY - 6.5, headX + 3, headY - 5);
  ctx.closePath();
  ctx.fill();
  // Chestnut nape extending from back of head
  ctx.fillStyle = '#8B3A1A';
  ctx.beginPath();
  ctx.arc(headX - 2, headY, headR - 1, Math.PI * 0.6, Math.PI * 1.2);
  ctx.quadraticCurveTo(headX - 6, headY + 2, headX - 4, headY - 2);
  ctx.closePath();
  ctx.fill();

  // â”€â”€ 6. Eye â€” PALE YELLOW iris â”€â”€
  // Blue-gray eye ring
  ctx.fillStyle = '#7a8a9a';
  ctx.beginPath();
  ctx.arc(headX + 2.5, headY - 0.5, 3, 0, Math.PI * 2);
  ctx.fill();
  // Pale yellow iris
  ctx.fillStyle = '#E8D44D';
  ctx.beginPath();
  ctx.arc(headX + 2.5, headY - 0.5, 2.2, 0, Math.PI * 2);
  ctx.fill();
  // Dark pupil
  ctx.fillStyle = '#1a1a1a';
  ctx.beginPath();
  ctx.arc(headX + 2.8, headY - 0.5, 1.1, 0, Math.PI * 2);
  ctx.fill();
  // Tiny white highlight
  ctx.fillStyle = '#FFF';
  ctx.beginPath();
  ctx.arc(headX + 3.3, headY - 1.2, 0.5, 0, Math.PI * 2);
  ctx.fill();

  // â”€â”€ 7. Beak â€” LONG, gray-beige, hooked tip â”€â”€
  const beakBase = headX + headR - 2;
  const beakY = headY + 1;
  const beakLen = 22;
  // Upper mandible
  ctx.fillStyle = '#9e9685';
  ctx.beginPath();
  ctx.moveTo(beakBase, beakY - 2.5);
  ctx.lineTo(beakBase + beakLen, beakY - 0.5);
  ctx.quadraticCurveTo(beakBase + beakLen + 1, beakY + 1, beakBase + beakLen - 1, beakY + 1.5); // hook
  ctx.lineTo(beakBase, beakY);
  ctx.closePath();
  ctx.fill();
  // Upper ridge (darker)
  ctx.strokeStyle = '#7a736a';
  ctx.lineWidth = 0.9;
  ctx.beginPath();
  ctx.moveTo(beakBase + 1, beakY - 2);
  ctx.lineTo(beakBase + beakLen - 1, beakY - 0.3);
  ctx.stroke();
  // Lower mandible
  ctx.fillStyle = '#a8a090';
  ctx.beginPath();
  ctx.moveTo(beakBase, beakY + 0.5);
  ctx.lineTo(beakBase + beakLen - 2, beakY + 1.5);
  ctx.lineTo(beakBase + beakLen - 3, beakY + 2.5);
  ctx.lineTo(beakBase, beakY + 2);
  ctx.closePath();
  ctx.fill();
  // Mandible seam/gap
  ctx.strokeStyle = 'rgba(60, 50, 40, 0.4)';
  ctx.lineWidth = 0.4;
  ctx.beginPath();
  ctx.moveTo(beakBase + 2, beakY + 0.2);
  ctx.lineTo(beakBase + beakLen - 2, beakY + 1.2);
  ctx.stroke();

  // â”€â”€ 8. Throat/gular pouch â€” olive-green, droopy â”€â”€
  const pouchX = beakBase + 4 + pouchSway * 0.3;
  const pouchY = beakY + 2;
  const pouchDroop = 8 + Math.sin(wp * 0.7) * 0.8;
  ctx.fillStyle = '#6b7a3a';
  ctx.beginPath();
  ctx.moveTo(beakBase, pouchY);
  ctx.lineTo(beakBase + beakLen - 4, pouchY + 1);
  ctx.quadraticCurveTo(beakBase + beakLen - 8 + pouchSway, pouchY + pouchDroop, beakBase + 6 + pouchSway * 0.5, pouchY + pouchDroop - 1);
  ctx.quadraticCurveTo(beakBase - 2 + pouchSway * 0.2, pouchY + pouchDroop * 0.5, beakBase - 1, pouchY + 1);
  ctx.closePath();
  ctx.fill();
  // Pouch highlight (lighter olive)
  ctx.fillStyle = 'rgba(138, 154, 80, 0.35)';
  ctx.beginPath();
  ctx.moveTo(beakBase + 4, pouchY + 2);
  ctx.quadraticCurveTo(beakBase + 10 + pouchSway, pouchY + pouchDroop - 2, beakBase + 8 + pouchSway * 0.5, pouchY + pouchDroop - 3);
  ctx.quadraticCurveTo(beakBase + 2, pouchY + pouchDroop * 0.4, beakBase + 2, pouchY + 2);
  ctx.closePath();
  ctx.fill();
  // Pouch outline
  ctx.strokeStyle = 'rgba(80, 90, 40, 0.5)';
  ctx.lineWidth = 0.6;
  ctx.beginPath();
  ctx.moveTo(beakBase + beakLen - 4, pouchY + 1);
  ctx.quadraticCurveTo(beakBase + beakLen - 8 + pouchSway, pouchY + pouchDroop, beakBase + 6 + pouchSway * 0.5, pouchY + pouchDroop - 1);
  ctx.quadraticCurveTo(beakBase - 2 + pouchSway * 0.2, pouchY + pouchDroop * 0.5, beakBase - 1, pouchY + 1);
  ctx.stroke();

  // â”€â”€ 9. Webbed feet â€” dark gray, totipalmate, tucked â”€â”€
  ctx.strokeStyle = '#4a4a4a';
  ctx.lineWidth = 1;
  ctx.fillStyle = 'rgba(90, 90, 90, 0.5)';
  // Left foot
  ctx.beginPath();
  ctx.moveTo(-1, hh);
  ctx.lineTo(-4, hh + 6);
  ctx.lineTo(-1, hh + 5);
  ctx.lineTo(1, hh + 7);
  ctx.lineTo(3, hh + 5);
  ctx.lineTo(5, hh + 6);
  ctx.lineTo(2, hh);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  // Right foot
  ctx.beginPath();
  ctx.moveTo(5, hh);
  ctx.lineTo(3, hh + 5);
  ctx.lineTo(5, hh + 4);
  ctx.lineTo(7, hh + 6);
  ctx.lineTo(9, hh + 4);
  ctx.lineTo(11, hh + 5);
  ctx.lineTo(8, hh);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  // Webbing lines between toes
  ctx.strokeStyle = 'rgba(60, 60, 60, 0.4)';
  ctx.lineWidth = 0.4;
  ctx.beginPath();
  ctx.moveTo(-2, hh + 5);
  ctx.lineTo(1, hh + 6);
  ctx.moveTo(1, hh + 6);
  ctx.lineTo(4, hh + 5);
  ctx.moveTo(4, hh + 4);
  ctx.lineTo(7, hh + 5);
  ctx.moveTo(7, hh + 5);
  ctx.lineTo(10, hh + 4);
  ctx.stroke();

  ctx.restore();
}

function drawScore() {
  ctx.save();
  ctx.textAlign = 'center';
  ctx.font = 'bold 52px "Georgia", serif';
  // Shadow
  ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
  ctx.fillText(score, W / 2 + 2, 62);
  // Outline
  ctx.strokeStyle = '#2a1a00';
  ctx.lineWidth = 4;
  ctx.strokeText(score, W / 2, 60);
  // Fill with warm gradient
  const scoreGrad = ctx.createLinearGradient(0, 20, 0, 65);
  scoreGrad.addColorStop(0, '#FFF8E0');
  scoreGrad.addColorStop(1, '#FFD700');
  ctx.fillStyle = scoreGrad;
  ctx.fillText(score, W / 2, 60);
  ctx.restore();
}

function drawMenu() {
  const habitat = getHabitat();
  habitat.drawBackground();
  habitat.drawWater();

  ctx.textAlign = 'center';

  // Title shadow
  ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
  ctx.font = 'bold 44px "Georgia", serif';
  ctx.fillText('FLAPPY PELICAN', W / 2 + 2, H / 3 + 2);

  // Title
  ctx.strokeStyle = '#2a1a00';
  ctx.lineWidth = 4;
  ctx.strokeText('FLAPPY PELICAN', W / 2, H / 3);
  const titleGrad = ctx.createLinearGradient(0, H / 3 - 35, 0, H / 3 + 5);
  titleGrad.addColorStop(0, '#FFF8E0');
  titleGrad.addColorStop(1, '#FFD700');
  ctx.fillStyle = titleGrad;
  ctx.fillText('FLAPPY PELICAN', W / 2, H / 3);

  // Subtitle
  ctx.font = 'italic 18px "Georgia", serif';
  ctx.fillStyle = '#fde8c8';
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.lineWidth = 2;
  ctx.strokeText('California Coast Edition', W / 2, H / 3 + 30);
  ctx.fillText('California Coast Edition', W / 2, H / 3 + 30);

  // Pelican preview (bobbing)
  const bobY = H / 2 - 20 + Math.sin(performance.now() / 300) * 10;
  pelican.y = bobY;
  pelican.rotation = 0;
  pelican.flapTimer = 0;
  pelican.wingPhase = performance.now() * 0.003;
  drawPelican();

  // â”€â”€ Idle sleep animation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const idleSeconds = (performance.now() - menuIdleStart) / 1000;
  if (idleSeconds > 15) {
    // Closed eyes â€” draw over pelican's eye area
    const eyeX = PELICAN_X + PELICAN_W / 2 + 12;
    const eyeY = bobY - 4;
    ctx.save();
    ctx.strokeStyle = '#2a1a00';
    ctx.lineWidth = 2;
    // Draw a small downward arc for closed eye
    ctx.beginPath();
    ctx.arc(eyeX, eyeY, 3, 0, Math.PI);
    ctx.stroke();
    ctx.restore();

    // Floating "z" letters
    const t = performance.now() / 1000;
    const zChars = ['z', 'z', 'Z'];
    const zSizes = [10, 13, 16];
    for (let i = 0; i < 3; i++) {
      const phase = t * 0.8 + i * 1.2;
      const floatY = eyeY - 15 - (i * 18) - ((phase % 3) * 8);
      const floatX = eyeX + 8 + Math.sin(phase * 1.5) * 5 + i * 4;
      const alpha = Math.max(0, 1 - (phase % 3) / 2.5);
      ctx.save();
      ctx.globalAlpha = alpha * 0.8;
      ctx.font = `bold ${zSizes[i]}px "Georgia", serif`;
      ctx.fillStyle = '#fde8c8';
      ctx.strokeStyle = 'rgba(0,0,0,0.4)';
      ctx.lineWidth = 1;
      ctx.strokeText(zChars[i], floatX, floatY);
      ctx.fillText(zChars[i], floatX, floatY);
      ctx.restore();
    }
  }

  // â”€â”€ Difficulty Selector â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const btnW = 120, btnH = 42, btnGap = 12;
  const totalW = 3 * btnW + 2 * btnGap;
  const startX = (W - totalW) / 2;
  const btnY = H / 2 + 50;
  const keys = ['easy', 'medium', 'hard'];
  difficultyButtons = []; // reset each frame

  for (let i = 0; i < 3; i++) {
    const key = keys[i];
    const d = DIFFICULTIES[key];
    const bx = startX + i * (btnW + btnGap);
    const isSelected = (key === currentDifficulty);

    // Store for hit-testing
    difficultyButtons.push({ key, x: bx, y: btnY, w: btnW, h: btnH });

    // Button background
    ctx.fillStyle = isSelected ? 'rgba(255, 215, 0, 0.25)' : 'rgba(30, 15, 5, 0.55)';
    ctx.strokeStyle = isSelected ? '#FFD700' : 'rgba(255, 255, 255, 0.25)';
    ctx.lineWidth = isSelected ? 2.5 : 1.5;
    roundRect(bx, btnY, btnW, btnH, 10);

    // Selected glow
    if (isSelected) {
      ctx.save();
      ctx.shadowColor = '#FFD700';
      ctx.shadowBlur = 12;
      ctx.strokeStyle = '#FFD700';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(bx + 10, btnY);
      ctx.lineTo(bx + btnW - 10, btnY);
      ctx.quadraticCurveTo(bx + btnW, btnY, bx + btnW, btnY + 10);
      ctx.lineTo(bx + btnW, btnY + btnH - 10);
      ctx.quadraticCurveTo(bx + btnW, btnY + btnH, bx + btnW - 10, btnY + btnH);
      ctx.lineTo(bx + 10, btnY + btnH);
      ctx.quadraticCurveTo(bx, btnY + btnH, bx, btnY + btnH - 10);
      ctx.lineTo(bx, btnY + 10);
      ctx.quadraticCurveTo(bx, btnY, bx + 10, btnY);
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }

    // Button label
    ctx.font = isSelected ? 'bold 16px "Georgia", serif' : '15px "Georgia", serif';
    ctx.fillStyle = isSelected ? '#FFD700' : '#fde8c8';
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.lineWidth = 1.5;
    const label = d.emoji + ' ' + d.label;
    ctx.strokeText(label, bx + btnW / 2, btnY + btnH / 2 + 6);
    ctx.fillText(label, bx + btnW / 2, btnY + btnH / 2 + 6);
  }

  // â”€â”€ Habitat Selector â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const habKeys = ['halfmoonbay', 'channelislands', 'lajolla', 'morrobay', 'bolsachica'];
  const hBtnW = 82, hBtnH = 34, hBtnGap = 6;
  const hTotalW = 5 * hBtnW + 4 * hBtnGap;
  const hStartX = (W - hTotalW) / 2;
  const hBtnY = btnY + btnH + 16;
  habitatButtons = [];

  for (let i = 0; i < 5; i++) {
    const hk = habKeys[i];
    const hab = HABITATS[hk];
    const hbx = hStartX + i * (hBtnW + hBtnGap);
    const isSel = (hk === currentHabitat);

    habitatButtons.push({ key: hk, x: hbx, y: hBtnY, w: hBtnW, h: hBtnH });

    ctx.fillStyle = isSel ? 'rgba(255, 215, 0, 0.25)' : 'rgba(30, 15, 5, 0.55)';
    ctx.strokeStyle = isSel ? '#FFD700' : 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = isSel ? 2 : 1;
    roundRect(hbx, hBtnY, hBtnW, hBtnH, 7);

    if (isSel) {
      ctx.save();
      ctx.shadowColor = '#FFD700'; ctx.shadowBlur = 8;
      ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(hbx + 7, hBtnY);
      ctx.lineTo(hbx + hBtnW - 7, hBtnY);
      ctx.quadraticCurveTo(hbx + hBtnW, hBtnY, hbx + hBtnW, hBtnY + 7);
      ctx.lineTo(hbx + hBtnW, hBtnY + hBtnH - 7);
      ctx.quadraticCurveTo(hbx + hBtnW, hBtnY + hBtnH, hbx + hBtnW - 7, hBtnY + hBtnH);
      ctx.lineTo(hbx + 7, hBtnY + hBtnH);
      ctx.quadraticCurveTo(hbx, hBtnY + hBtnH, hbx, hBtnY + hBtnH - 7);
      ctx.lineTo(hbx, hBtnY + 7);
      ctx.quadraticCurveTo(hbx, hBtnY, hbx + 7, hBtnY);
      ctx.closePath(); ctx.stroke();
      ctx.restore();
    }

    ctx.font = isSel ? 'bold 11px "Georgia", serif' : '10px "Georgia", serif';
    ctx.fillStyle = isSel ? '#FFD700' : '#fde8c8';
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.lineWidth = 1;
    const hLabel = hab.emoji + ' ' + hab.shortName;
    ctx.strokeText(hLabel, hbx + hBtnW / 2, hBtnY + hBtnH / 2 + 4);
    ctx.fillText(hLabel, hbx + hBtnW / 2, hBtnY + hBtnH / 2 + 4);
  }

  // Habitat description
  const selHab = getHabitat();
  ctx.font = 'italic 11px "Georgia", serif';
  ctx.fillStyle = 'rgba(253, 232, 200, 0.7)';
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
  ctx.lineWidth = 1;
  ctx.strokeText(selHab.description, W / 2, hBtnY + hBtnH + 16);
  ctx.fillText(selHab.description, W / 2, hBtnY + hBtnH + 16);

  // Best score for selected difficulty
  const infoY = hBtnY + hBtnH + 32;
  if (bestScore > 0) {
    ctx.font = '16px "Georgia", serif';
    ctx.fillStyle = '#fde8c8';
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.lineWidth = 1.5;
    ctx.strokeText('Best (' + DIFFICULTIES[currentDifficulty].label + '): ' + bestScore, W / 2, infoY);
    ctx.fillText('Best (' + DIFFICULTIES[currentDifficulty].label + '): ' + bestScore, W / 2, infoY);
  }

  // Instruction with pulsing opacity
  const pulse = 0.6 + Math.sin(performance.now() / 500) * 0.4;
  ctx.globalAlpha = pulse;
  ctx.font = '18px "Georgia", serif';
  ctx.fillStyle = '#FFF';
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
  ctx.lineWidth = 2;
  const instrY = infoY + (bestScore > 0 ? 30 : 0);
  ctx.strokeText('Tap or press Space to play', W / 2, instrY);
  ctx.fillText('Tap or press Space to play', W / 2, instrY);
  ctx.globalAlpha = 1;
}

function drawGameOver() {
  const d = DIFFICULTIES[currentDifficulty];

  // Dim overlay
  ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';

  // Score panel background
  const panelX = W / 2 - 120, panelY = H / 3 - 50;
  ctx.fillStyle = 'rgba(30, 15, 5, 0.7)';
  ctx.strokeStyle = '#D4A017';
  ctx.lineWidth = 2;
  roundRect(panelX, panelY, 240, 220, 12);

  // Game Over text
  ctx.font = 'bold 38px "Georgia", serif';
  ctx.strokeStyle = '#2a1a00';
  ctx.lineWidth = 3;
  const goGrad = ctx.createLinearGradient(0, panelY + 10, 0, panelY + 50);
  goGrad.addColorStop(0, '#FFF8E0');
  goGrad.addColorStop(1, '#FFD700');
  ctx.strokeText('Game Over', W / 2, panelY + 40);
  ctx.fillStyle = goGrad;
  ctx.fillText('Game Over', W / 2, panelY + 40);

  // Difficulty label
  ctx.font = '16px "Georgia", serif';
  ctx.fillStyle = '#fde8c8';
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.lineWidth = 1.5;
  ctx.strokeText(d.label + ' ' + d.emoji, W / 2, panelY + 65);
  ctx.fillText(d.label + ' ' + d.emoji, W / 2, panelY + 65);

  // Score
  ctx.font = 'bold 28px "Georgia", serif';
  ctx.fillStyle = '#FFF';
  ctx.strokeStyle = '#2a1a00';
  ctx.lineWidth = 2;
  ctx.strokeText('Score: ' + score, W / 2, panelY + 100);
  ctx.fillText('Score: ' + score, W / 2, panelY + 100);

  // Best score
  ctx.font = '22px "Georgia", serif';
  ctx.fillStyle = '#FFD700';
  ctx.strokeText('Best: ' + bestScore, W / 2, panelY + 135);
  ctx.fillText('Best: ' + bestScore, W / 2, panelY + 135);

  // New best indicator
  if (score >= bestScore && score > 0) {
    ctx.font = 'bold 16px "Georgia", serif';
    ctx.fillStyle = '#ff6b6b';
    ctx.fillText('â˜… NEW BEST! â˜…', W / 2, panelY + 165);
  }

  // Restart instruction
  const pulse = 0.6 + Math.sin(performance.now() / 500) * 0.4;
  ctx.globalAlpha = pulse;
  ctx.font = '18px "Georgia", serif';
  ctx.fillStyle = '#fde8c8';
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.lineWidth = 1.5;
  ctx.strokeText('Tap to play again', W / 2, panelY + 200);
  ctx.fillText('Tap to play again', W / 2, panelY + 200);
  ctx.globalAlpha = 1;
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}

// â”€â”€ Main Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gameLoop(now) {
  update(now);

  let shaking = shakeTimer > 0;
  if (shaking) {
    ctx.save();
    const sx = (Math.random() - 0.5) * shakeIntensity * 2;
    const sy = (Math.random() - 0.5) * shakeIntensity * 2;
    ctx.translate(sx, sy);
    shakeTimer--;
    shakeIntensity *= 0.85;
  }

  const habitat = getHabitat();
  if (state === 'menu') {
    drawMenu();
  } else if (state === 'playing') {
    habitat.drawBackground();
    drawPipes();
    habitat.drawWater();
    drawPelican();
    drawScore();
    drawScorePopups();
  } else if (state === 'game_over') {
    habitat.drawBackground();
    drawPipes();
    habitat.drawWater();
    drawPelican();
    drawScore();
    drawScorePopups();
    drawGameOver();
  }

  if (shaking) {
    ctx.restore();
  }

  requestAnimationFrame(gameLoop);
}

// â”€â”€ Start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
resetGame();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>

