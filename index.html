<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Flappy Pelican — California Coast Edition</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { width: 100%; height: 100%; overflow: hidden; background: #1a0a2e; display: flex; justify-content: center; align-items: center; }
  canvas { display: block; touch-action: none; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
// ── Constants ──────────────────────────────────────────────
const W = 480, H = 640;
const GRAVITY = 0.35;
const FLAP_STRENGTH = -7.0;
const PIPE_SPEED = 2.0;
const PIPE_WIDTH = 60;
const PIPE_GAP = 160;
const PIPE_SPAWN_INTERVAL = 2000;
const GROUND_HEIGHT = 60;
const PELICAN_W = 40, PELICAN_H = 30;
const PELICAN_X = 80;

// ── Canvas Setup ───────────────────────────────────────────
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = W;
canvas.height = H;

// ── Responsive Scaling ────────────────────────────────────
function resizeCanvas() {
  const scaleX = window.innerWidth / W;
  const scaleY = window.innerHeight / H;
  const scale = Math.min(scaleX, scaleY);
  canvas.style.width = (W * scale) + 'px';
  canvas.style.height = (H * scale) + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ── High Score ────────────────────────────────────────────
let bestScore = parseInt(localStorage.getItem('flappyPelicanBest') || '0', 10);

// ── Game State ─────────────────────────────────────────────
let state = 'menu';
let pelican = { y: 0, vy: 0, rotation: 0, wingPhase: 0, flapTimer: 0 };
let pipes = [];
let score = 0;
let lastPipeSpawn = 0;
let lastTime = 0;
let groundOffset = 0;
let parallaxOffset = 0;

function resetGame() {
  pelican.y = H / 2 - 50;
  pelican.vy = 0;
  pelican.rotation = 0;
  pelican.wingPhase = 0;
  pelican.flapTimer = 0;
  pipes = [];
  score = 0;
  lastPipeSpawn = 0;
  lastTime = 0;
  groundOffset = 0;
}

// ── Input ──────────────────────────────────────────────────
function handleInput() {
  if (state === 'menu') {
    state = 'playing';
    resetGame();
    lastTime = performance.now();
  } else if (state === 'playing') {
    pelican.vy = FLAP_STRENGTH;
    pelican.flapTimer = 12; // frames of wing-up animation
  } else if (state === 'game_over') {
    state = 'menu';
  }
}

canvas.addEventListener('pointerdown', (e) => { e.preventDefault(); handleInput(); });
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.key === ' ') { e.preventDefault(); handleInput(); }
});

// ── Pipe Generation ────────────────────────────────────────
function spawnPipe() {
  const minTop = 80;
  const maxTop = H - GROUND_HEIGHT - PIPE_GAP - 80;
  const topHeight = minTop + Math.random() * (maxTop - minTop);
  pipes.push({
    x: W + 10,
    topH: topHeight,
    bottomY: topHeight + PIPE_GAP,
    scored: false
  });
}

// ── Collision Detection ────────────────────────────────────
function checkCollision() {
  const px = PELICAN_X, py = pelican.y;
  const pw = PELICAN_W, ph = PELICAN_H;

  // Ground & ceiling
  if (py + ph >= H - GROUND_HEIGHT) return true;
  if (py <= 0) return true;

  // Pipes
  for (const pipe of pipes) {
    if (px + pw > pipe.x && px < pipe.x + PIPE_WIDTH) {
      if (py < pipe.topH || py + ph > pipe.bottomY) {
        return true;
      }
    }
  }
  return false;
}

// ── Update ─────────────────────────────────────────────────
function update(now) {
  if (state !== 'playing') return;

  const dt = Math.min((now - lastTime) / 16.667, 3); // normalize to ~60fps, cap
  lastTime = now;

  // Pelican physics
  pelican.vy += GRAVITY * dt;
  pelican.y += pelican.vy * dt;

  // Rotation based on velocity
  const targetRot = Math.max(-0.5, Math.min(pelican.vy / 10, 1.2));
  pelican.rotation += (targetRot - pelican.rotation) * 0.15 * dt;

  // Wing animation
  if (pelican.flapTimer > 0) pelican.flapTimer -= dt;
  pelican.wingPhase += 0.15 * dt;

  // Ground scroll & parallax
  groundOffset = (groundOffset + PIPE_SPEED * dt) % 24;
  parallaxOffset += PIPE_SPEED * dt;

  // Pipe spawning (time-based)
  if (pipes.length === 0 || (now - lastPipeSpawn) > PIPE_SPAWN_INTERVAL) {
    spawnPipe();
    lastPipeSpawn = now;
  }

  // Move pipes & score
  for (let i = pipes.length - 1; i >= 0; i--) {
    pipes[i].x -= PIPE_SPEED * dt;

    // Score when pelican passes pipe center
    if (!pipes[i].scored && pipes[i].x + PIPE_WIDTH < PELICAN_X) {
      pipes[i].scored = true;
      score++;
    }

    // Remove off-screen pipes
    if (pipes[i].x + PIPE_WIDTH < -10) {
      pipes.splice(i, 1);
    }
  }

  // Collision
  if (checkCollision()) {
    state = 'game_over';
    if (score > bestScore) {
      bestScore = score;
      localStorage.setItem('flappyPelicanBest', String(bestScore));
    }
  }
}
// ── Drawing ────────────────────────────────────────────────
function drawBackground() {
  // Sunset sky gradient
  const grad = ctx.createLinearGradient(0, 0, 0, H - GROUND_HEIGHT);
  grad.addColorStop(0, '#1a0a3e');
  grad.addColorStop(0.25, '#4a1942');
  grad.addColorStop(0.45, '#c0392b');
  grad.addColorStop(0.6, '#e67e22');
  grad.addColorStop(0.75, '#f39c12');
  grad.addColorStop(1, '#fdeaa8');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H - GROUND_HEIGHT);

  // Sun glow
  const sunY = (H - GROUND_HEIGHT) * 0.62;
  const sunGrad = ctx.createRadialGradient(W * 0.7, sunY, 10, W * 0.7, sunY, 120);
  sunGrad.addColorStop(0, 'rgba(255, 220, 100, 0.8)');
  sunGrad.addColorStop(0.3, 'rgba(255, 180, 60, 0.3)');
  sunGrad.addColorStop(1, 'rgba(255, 100, 50, 0)');
  ctx.fillStyle = sunGrad;
  ctx.fillRect(0, 0, W, H - GROUND_HEIGHT);

  // Sun disc
  ctx.fillStyle = '#ffe066';
  ctx.beginPath();
  ctx.arc(W * 0.7, sunY, 30, 0, Math.PI * 2);
  ctx.fill();

  // ── Parallax Layer 1: Distant clouds ──
  ctx.fillStyle = 'rgba(255, 200, 150, 0.25)';
  const cloudSpeed1 = parallaxOffset * 0.15;
  for (let i = 0; i < 4; i++) {
    const cx = ((i * 160 + 40 - cloudSpeed1) % (W + 120)) - 60;
    drawCloud(cx, 60 + i * 25, 50 + i * 10, 0.2 + i * 0.05);
  }

  // ── Parallax Layer 2: Distant hills/coastline ──
  const hillSpeed = parallaxOffset * 0.3;
  ctx.fillStyle = '#2d1b4e';
  ctx.beginPath();
  ctx.moveTo(0, H - GROUND_HEIGHT);
  for (let x = 0; x <= W; x += 2) {
    const h = Math.sin((x + hillSpeed) * 0.008) * 40 + Math.sin((x + hillSpeed) * 0.02) * 20 + 60;
    ctx.lineTo(x, H - GROUND_HEIGHT - h);
  }
  ctx.lineTo(W, H - GROUND_HEIGHT);
  ctx.closePath();
  ctx.fill();

  // ── Parallax Layer 3: Closer hills with palm tree silhouettes ──
  const hillSpeed2 = parallaxOffset * 0.5;
  ctx.fillStyle = '#1a0f30';
  ctx.beginPath();
  ctx.moveTo(0, H - GROUND_HEIGHT);
  for (let x = 0; x <= W; x += 2) {
    const h = Math.sin((x + hillSpeed2) * 0.012) * 25 + Math.sin((x + hillSpeed2) * 0.03) * 15 + 35;
    ctx.lineTo(x, H - GROUND_HEIGHT - h);
  }
  ctx.lineTo(W, H - GROUND_HEIGHT);
  ctx.closePath();
  ctx.fill();

  // Palm tree silhouettes on closer hills
  ctx.fillStyle = '#1a0f30';
  for (let i = 0; i < 3; i++) {
    const px = ((i * 200 + 80 - hillSpeed2) % (W + 100)) - 50;
    const baseH = Math.sin((px + hillSpeed2) * 0.012) * 25 + Math.sin((px + hillSpeed2) * 0.03) * 15 + 35;
    drawPalmSilhouette(px, H - GROUND_HEIGHT - baseH);
  }
}

function drawCloud(x, y, size, alpha) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = 'rgba(255, 220, 180, 0.6)';
  ctx.beginPath();
  ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
  ctx.arc(x + size * 0.35, y - size * 0.15, size * 0.4, 0, Math.PI * 2);
  ctx.arc(x + size * 0.7, y, size * 0.35, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawPalmSilhouette(x, baseY) {
  // Trunk
  ctx.save();
  ctx.strokeStyle = '#1a0f30';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(x, baseY);
  ctx.quadraticCurveTo(x + 5, baseY - 25, x + 3, baseY - 45);
  ctx.stroke();
  // Fronds
  ctx.fillStyle = '#1a0f30';
  for (let a = -2.5; a <= 0.5; a += 0.5) {
    ctx.beginPath();
    ctx.moveTo(x + 3, baseY - 45);
    const fx = x + 3 + Math.cos(a) * 22;
    const fy = baseY - 45 + Math.sin(a) * 18;
    ctx.quadraticCurveTo(x + 3 + Math.cos(a) * 12, baseY - 45 + Math.sin(a) * 5, fx, fy);
    ctx.quadraticCurveTo(x + 3 + Math.cos(a) * 14, baseY - 45 + Math.sin(a) * 10, x + 3, baseY - 45);
    ctx.fill();
  }
  ctx.restore();
}

function drawWater() {
  const waterY = H - GROUND_HEIGHT;
  // Deep water base
  const wGrad = ctx.createLinearGradient(0, waterY, 0, H);
  wGrad.addColorStop(0, '#1a3a5c');
  wGrad.addColorStop(0.3, '#0d2137');
  wGrad.addColorStop(1, '#091520');
  ctx.fillStyle = wGrad;
  ctx.fillRect(0, waterY, W, GROUND_HEIGHT);

  // Sunset reflection on water
  const refGrad = ctx.createLinearGradient(0, waterY, 0, waterY + 30);
  refGrad.addColorStop(0, 'rgba(255, 150, 50, 0.3)');
  refGrad.addColorStop(1, 'rgba(255, 100, 30, 0)');
  ctx.fillStyle = refGrad;
  ctx.fillRect(0, waterY, W, 30);

  // Animated waves
  const t = performance.now() * 0.002;
  ctx.strokeStyle = 'rgba(100, 180, 255, 0.25)';
  ctx.lineWidth = 1.5;
  for (let row = 0; row < 3; row++) {
    ctx.beginPath();
    const wy = waterY + 8 + row * 18;
    for (let x = 0; x <= W; x += 3) {
      const wave = Math.sin((x - groundOffset * 3 + row * 40) * 0.04 + t + row) * 3;
      if (x === 0) ctx.moveTo(x, wy + wave);
      else ctx.lineTo(x, wy + wave);
    }
    ctx.stroke();
  }

  // Sparkle highlights
  ctx.fillStyle = 'rgba(255, 230, 150, 0.4)';
  for (let i = 0; i < 6; i++) {
    const sx = ((i * 87 + t * 20 + parallaxOffset * 0.5) % W);
    const sy = waterY + 5 + (i * 13) % 40;
    const sparkle = Math.sin(t * 3 + i * 2) * 0.5 + 0.5;
    if (sparkle > 0.7) {
      ctx.globalAlpha = sparkle - 0.5;
      ctx.fillRect(sx, sy, 2, 1);
      ctx.globalAlpha = 1;
    }
  }
}

function drawPilingTexture(x, y, w, h) {
  // Wood grain lines
  ctx.strokeStyle = 'rgba(60, 30, 10, 0.3)';
  ctx.lineWidth = 1;
  for (let gx = x + 6; gx < x + w - 4; gx += 8) {
    ctx.beginPath();
    ctx.moveTo(gx + Math.sin(y * 0.1) * 2, y);
    for (let gy = y; gy < y + h; gy += 10) {
      ctx.lineTo(gx + Math.sin(gy * 0.05) * 2, gy);
    }
    ctx.stroke();
  }
  // Barnacles (small circles near bottom)
  ctx.fillStyle = 'rgba(140, 140, 120, 0.6)';
  for (let i = 0; i < 5; i++) {
    const bx = x + 8 + ((i * 17 + Math.floor(x)) % (w - 16));
    const by = y + h - 15 - ((i * 23) % 30);
    const br = 2 + (i % 2);
    ctx.beginPath();
    ctx.arc(bx, by, br, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawPipes() {
  for (const pipe of pipes) {
    // ── Top piling (hangs from top) ──
    // Main wood body
    const topGrad = ctx.createLinearGradient(pipe.x, 0, pipe.x + PIPE_WIDTH, 0);
    topGrad.addColorStop(0, '#5c3a1e');
    topGrad.addColorStop(0.3, '#8B6914');
    topGrad.addColorStop(0.6, '#7a5a2e');
    topGrad.addColorStop(1, '#4a2a10');
    ctx.fillStyle = topGrad;
    ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.topH);
    // Cap (wider crossbeam)
    const capGrad = ctx.createLinearGradient(pipe.x - 4, 0, pipe.x + PIPE_WIDTH + 4, 0);
    capGrad.addColorStop(0, '#6b4420');
    capGrad.addColorStop(0.5, '#9a7040');
    capGrad.addColorStop(1, '#5a3418');
    ctx.fillStyle = capGrad;
    ctx.fillRect(pipe.x - 4, pipe.topH - 20, PIPE_WIDTH + 8, 20);
    // Border
    ctx.strokeStyle = '#3a1a08';
    ctx.lineWidth = 2;
    ctx.strokeRect(pipe.x, 0, PIPE_WIDTH, pipe.topH);
    ctx.strokeRect(pipe.x - 4, pipe.topH - 20, PIPE_WIDTH + 8, 20);
    drawPilingTexture(pipe.x, 0, PIPE_WIDTH, pipe.topH);

    // ── Bottom piling (rises from water) ──
    const bH = H - GROUND_HEIGHT - pipe.bottomY;
    const botGrad = ctx.createLinearGradient(pipe.x, 0, pipe.x + PIPE_WIDTH, 0);
    botGrad.addColorStop(0, '#5c3a1e');
    botGrad.addColorStop(0.3, '#8B6914');
    botGrad.addColorStop(0.6, '#7a5a2e');
    botGrad.addColorStop(1, '#4a2a10');
    ctx.fillStyle = botGrad;
    ctx.fillRect(pipe.x, pipe.bottomY, PIPE_WIDTH, bH);
    // Cap
    ctx.fillStyle = capGrad;
    ctx.fillRect(pipe.x - 4, pipe.bottomY, PIPE_WIDTH + 8, 20);
    // Border
    ctx.strokeStyle = '#3a1a08';
    ctx.lineWidth = 2;
    ctx.strokeRect(pipe.x, pipe.bottomY, PIPE_WIDTH, bH);
    ctx.strokeRect(pipe.x - 4, pipe.bottomY, PIPE_WIDTH + 8, 20);
    drawPilingTexture(pipe.x, pipe.bottomY, PIPE_WIDTH, bH);

    // Green algae/seaweed at waterline on bottom piling
    ctx.fillStyle = 'rgba(50, 120, 50, 0.4)';
    const algaeY = H - GROUND_HEIGHT - 8;
    for (let ax = pipe.x + 2; ax < pipe.x + PIPE_WIDTH - 2; ax += 5) {
      const ah = 4 + Math.sin(ax * 0.3) * 3;
      ctx.fillRect(ax, algaeY - ah, 3, ah + 8);
    }
  }
}

function drawPelican() {
  ctx.save();
  ctx.translate(PELICAN_X + PELICAN_W / 2, pelican.y + PELICAN_H / 2);
  ctx.rotate(pelican.rotation);

  const hw = PELICAN_W / 2, hh = PELICAN_H / 2;

  // ── Tail feathers ──
  ctx.fillStyle = '#5a3e1a';
  ctx.beginPath();
  ctx.moveTo(-hw - 2, -2);
  ctx.lineTo(-hw - 12, -6);
  ctx.lineTo(-hw - 14, 0);
  ctx.lineTo(-hw - 12, 5);
  ctx.lineTo(-hw - 2, 3);
  ctx.closePath();
  ctx.fill();

  // ── Body (oval, brown) ──
  ctx.fillStyle = '#6B4226';
  ctx.beginPath();
  ctx.ellipse(0, 0, hw + 2, hh, 0, 0, Math.PI * 2);
  ctx.fill();
  // Body highlight
  ctx.fillStyle = 'rgba(139, 90, 43, 0.5)';
  ctx.beginPath();
  ctx.ellipse(-2, -3, hw - 4, hh - 5, 0, 0, Math.PI * 2);
  ctx.fill();

  // ── Wing (animated) ──
  const flapping = pelican.flapTimer > 0;
  let wingY = 0;
  if (flapping) {
    wingY = -8 - Math.sin(pelican.flapTimer * 0.8) * 6; // wings up during flap
  } else {
    wingY = 2 + Math.sin(pelican.wingPhase) * 2; // gentle glide bob
  }
  // Wing shape
  ctx.fillStyle = '#4a2e14';
  ctx.beginPath();
  ctx.moveTo(-hw + 6, 0);
  ctx.quadraticCurveTo(-4, wingY - 6, 6, wingY - 4);
  ctx.quadraticCurveTo(2, wingY + 4, -hw + 6, 4);
  ctx.closePath();
  ctx.fill();
  // Wing feather detail
  ctx.strokeStyle = 'rgba(90, 60, 30, 0.5)';
  ctx.lineWidth = 0.7;
  ctx.beginPath();
  ctx.moveTo(-hw + 10, 1);
  ctx.quadraticCurveTo(-2, wingY - 2, 4, wingY - 1);
  ctx.stroke();

  // ── Neck (white/cream, connects body to head) ──
  ctx.fillStyle = '#F5E6C8';
  ctx.beginPath();
  ctx.moveTo(hw - 8, -hh + 2);
  ctx.quadraticCurveTo(hw + 2, -hh - 6, hw + 4, -hh - 10);
  ctx.quadraticCurveTo(hw + 6, -hh - 4, hw, -hh + 6);
  ctx.closePath();
  ctx.fill();

  // ── Head (white/cream, round) ──
  ctx.fillStyle = '#FFF8E7';
  ctx.beginPath();
  ctx.arc(hw + 2, -hh - 10, 7, 0, Math.PI * 2);
  ctx.fill();
  // Crown (slight brown tinge on top of head — California Brown Pelican breeding plumage)
  ctx.fillStyle = 'rgba(120, 60, 20, 0.35)';
  ctx.beginPath();
  ctx.arc(hw + 1, -hh - 13, 5, Math.PI, 0);
  ctx.fill();

  // ── Beak (long, yellow-orange with hook) ──
  ctx.fillStyle = '#D4A017';
  ctx.beginPath();
  ctx.moveTo(hw + 8, -hh - 12);
  ctx.lineTo(hw + 24, -hh - 8);
  ctx.lineTo(hw + 23, -hh - 6); // hook tip
  ctx.lineTo(hw + 8, -hh - 5);
  ctx.closePath();
  ctx.fill();
  // Beak upper ridge
  ctx.strokeStyle = '#b8860b';
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.moveTo(hw + 8, -hh - 11);
  ctx.lineTo(hw + 22, -hh - 8);
  ctx.stroke();

  // ── Throat pouch (signature pelican feature) ──
  ctx.fillStyle = 'rgba(210, 160, 60, 0.6)';
  ctx.beginPath();
  ctx.moveTo(hw + 8, -hh - 5);
  ctx.quadraticCurveTo(hw + 16, -hh + 2, hw + 8, -hh + 1);
  ctx.quadraticCurveTo(hw + 4, -hh - 1, hw + 8, -hh - 5);
  ctx.fill();
  // Pouch outline
  ctx.strokeStyle = 'rgba(180, 130, 40, 0.5)';
  ctx.lineWidth = 0.6;
  ctx.beginPath();
  ctx.moveTo(hw + 8, -hh - 5);
  ctx.quadraticCurveTo(hw + 16, -hh + 2, hw + 8, -hh + 1);
  ctx.stroke();

  // ── Eye ──
  ctx.fillStyle = '#FFF';
  ctx.beginPath();
  ctx.arc(hw + 5, -hh - 11, 2.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#1a1a1a';
  ctx.beginPath();
  ctx.arc(hw + 5.5, -hh - 11, 1.5, 0, Math.PI * 2);
  ctx.fill();
  // Eye highlight
  ctx.fillStyle = '#FFF';
  ctx.beginPath();
  ctx.arc(hw + 6, -hh - 11.5, 0.5, 0, Math.PI * 2);
  ctx.fill();

  // ── Feet (tucked, visible during flight) ──
  ctx.strokeStyle = '#D4A017';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(2, hh - 1);
  ctx.lineTo(5, hh + 5);
  ctx.moveTo(0, hh - 1);
  ctx.lineTo(-2, hh + 5);
  ctx.stroke();

  ctx.restore();
}

function drawScore() {
  ctx.save();
  ctx.textAlign = 'center';
  ctx.font = 'bold 52px "Georgia", serif';
  // Shadow
  ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
  ctx.fillText(score, W / 2 + 2, 62);
  // Outline
  ctx.strokeStyle = '#2a1a00';
  ctx.lineWidth = 4;
  ctx.strokeText(score, W / 2, 60);
  // Fill with warm gradient
  const scoreGrad = ctx.createLinearGradient(0, 20, 0, 65);
  scoreGrad.addColorStop(0, '#FFF8E0');
  scoreGrad.addColorStop(1, '#FFD700');
  ctx.fillStyle = scoreGrad;
  ctx.fillText(score, W / 2, 60);
  ctx.restore();
}

function drawMenu() {
  drawBackground();
  drawWater();

  ctx.textAlign = 'center';

  // Title shadow
  ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
  ctx.font = 'bold 44px "Georgia", serif';
  ctx.fillText('FLAPPY PELICAN', W / 2 + 2, H / 3 + 2);

  // Title
  ctx.strokeStyle = '#2a1a00';
  ctx.lineWidth = 4;
  ctx.strokeText('FLAPPY PELICAN', W / 2, H / 3);
  const titleGrad = ctx.createLinearGradient(0, H / 3 - 35, 0, H / 3 + 5);
  titleGrad.addColorStop(0, '#FFF8E0');
  titleGrad.addColorStop(1, '#FFD700');
  ctx.fillStyle = titleGrad;
  ctx.fillText('FLAPPY PELICAN', W / 2, H / 3);

  // Subtitle
  ctx.font = 'italic 18px "Georgia", serif';
  ctx.fillStyle = '#fde8c8';
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.lineWidth = 2;
  ctx.strokeText('California Coast Edition', W / 2, H / 3 + 30);
  ctx.fillText('California Coast Edition', W / 2, H / 3 + 30);

  // Pelican preview (bobbing)
  const bobY = H / 2 - 20 + Math.sin(performance.now() / 300) * 10;
  pelican.y = bobY;
  pelican.rotation = 0;
  pelican.flapTimer = 0;
  pelican.wingPhase = performance.now() * 0.003;
  drawPelican();

  // Instruction with pulsing opacity
  const pulse = 0.6 + Math.sin(performance.now() / 500) * 0.4;
  ctx.globalAlpha = pulse;
  ctx.font = '20px "Georgia", serif';
  ctx.fillStyle = '#FFF';
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
  ctx.lineWidth = 2;
  ctx.strokeText('Tap or press Space to play', W / 2, H / 2 + 70);
  ctx.fillText('Tap or press Space to play', W / 2, H / 2 + 70);
  ctx.globalAlpha = 1;

  // Best score (if any)
  if (bestScore > 0) {
    ctx.font = '16px "Georgia", serif';
    ctx.fillStyle = '#fde8c8';
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.lineWidth = 1.5;
    ctx.strokeText('Best: ' + bestScore, W / 2, H / 2 + 100);
    ctx.fillText('Best: ' + bestScore, W / 2, H / 2 + 100);
  }
}

function drawGameOver() {
  // Dim overlay
  ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';

  // Score panel background
  const panelX = W / 2 - 120, panelY = H / 3 - 50;
  ctx.fillStyle = 'rgba(30, 15, 5, 0.7)';
  ctx.strokeStyle = '#D4A017';
  ctx.lineWidth = 2;
  roundRect(panelX, panelY, 240, 200, 12);

  // Game Over text
  ctx.font = 'bold 38px "Georgia", serif';
  ctx.strokeStyle = '#2a1a00';
  ctx.lineWidth = 3;
  const goGrad = ctx.createLinearGradient(0, panelY + 10, 0, panelY + 50);
  goGrad.addColorStop(0, '#FFF8E0');
  goGrad.addColorStop(1, '#FFD700');
  ctx.strokeText('Game Over', W / 2, panelY + 40);
  ctx.fillStyle = goGrad;
  ctx.fillText('Game Over', W / 2, panelY + 40);

  // Score
  ctx.font = 'bold 28px "Georgia", serif';
  ctx.fillStyle = '#FFF';
  ctx.strokeStyle = '#2a1a00';
  ctx.lineWidth = 2;
  ctx.strokeText('Score: ' + score, W / 2, panelY + 90);
  ctx.fillText('Score: ' + score, W / 2, panelY + 90);

  // Best score
  ctx.font = '22px "Georgia", serif';
  ctx.fillStyle = '#FFD700';
  ctx.strokeText('Best: ' + bestScore, W / 2, panelY + 125);
  ctx.fillText('Best: ' + bestScore, W / 2, panelY + 125);

  // New best indicator
  if (score >= bestScore && score > 0) {
    ctx.font = 'bold 16px "Georgia", serif';
    ctx.fillStyle = '#ff6b6b';
    ctx.fillText('★ NEW BEST! ★', W / 2, panelY + 155);
  }

  // Restart instruction
  const pulse = 0.6 + Math.sin(performance.now() / 500) * 0.4;
  ctx.globalAlpha = pulse;
  ctx.font = '18px "Georgia", serif';
  ctx.fillStyle = '#fde8c8';
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.lineWidth = 1.5;
  ctx.strokeText('Tap to play again', W / 2, panelY + 185);
  ctx.fillText('Tap to play again', W / 2, panelY + 185);
  ctx.globalAlpha = 1;
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}

// ── Main Loop ──────────────────────────────────────────────
function gameLoop(now) {
  update(now);

  if (state === 'menu') {
    drawMenu();
  } else if (state === 'playing') {
    drawBackground();
    drawPipes();
    drawWater();
    drawPelican();
    drawScore();
  } else if (state === 'game_over') {
    drawBackground();
    drawPipes();
    drawWater();
    drawPelican();
    drawScore();
    drawGameOver();
  }

  requestAnimationFrame(gameLoop);
}

// ── Start ──────────────────────────────────────────────────
resetGame();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>

